<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZCC的博客</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="https://blog.zcchub.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.zcchub.xyz/"/>
  <updated>2022-04-02T14:48:25.449Z</updated>
  <id>https://blog.zcchub.xyz/</id>
  
  <author>
    <name>Zcc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1 核 1G 的 VPS 能玩出什么花样</title>
    <link href="https://blog.zcchub.xyz/vps/selfhosted/"/>
    <id>https://blog.zcchub.xyz/vps/selfhosted/</id>
    <published>2022-03-27T06:25:47.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 <code>nohup</code>, <code>systemd</code> 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 <code>ssh</code> 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...</p><span id="more"></span><h2 id="免备案"><a href="#免备案" class="headerlink" title="免备案"></a>免备案</h2><p>没有什么歪门邪道，如果嫌备案麻烦，就老老实实多花一点钱买个香港的机子（或者新加坡，日本，洛杉矶 ...），跑一些个人小项目足矣。它们不仅免备案，<strong>而且</strong>在使用大部分包管理工具的时候都可以直接用默认的源，👍 速度超赞</p><h2 id="CapRover"><a href="#CapRover" class="headerlink" title="CapRover"></a>CapRover</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jYXByb3Zlci5jb20v">CapRover<i class="fa fa-external-link-alt"></i></span> 是 Heroku 的 self-hosted 替代方案，它完全开源，每月 5$ 的 1C1G 机子就可以运行</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>其实 <span class="exturl" data-url="aHR0cHM6Ly9kb2trdS5jb20v">Dokku<i class="fa fa-external-link-alt"></i></span> 也挺不错，只是我更喜欢在 Web 界面上操作，<code>Dockerfile</code> 也能满足大部分应用的需求。最重要的是 CapRover 有一个叫 <strong>One Click Apps</strong> 的功能，能一键部署 Gitea, Gitlab, Drone, Wordpress, Ghost 等常见应用，😅 有点像宝塔，有一说一还挺香</p><table><thead><tr><th align="center">CapRover</th><th align="center">Dokku</th><th align="center">Heroku</th></tr></thead><tbody><tr><td align="center">便宜</td><td align="center">便宜</td><td align="center">贵</td></tr><tr><td align="center">只支持 Dockerfile 或 docker-compose</td><td align="center">各种 buildpacks</td><td align="center">各种 buildpacks</td></tr><tr><td align="center">有 Web 界面</td><td align="center">ShellScript</td><td align="center">有 Web 界面</td></tr><tr><td align="center">基于 Docker Swarm</td><td align="center">基于 Docker</td><td align="center">-</td></tr></tbody></table><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>照着官网的 <span class="exturl" data-url="aHR0cHM6Ly9jYXByb3Zlci5jb20vZG9jcy9nZXQtc3RhcnRlZC5odG1s">Getting Started<i class="fa fa-external-link-alt"></i></span> 慢慢做就行，注意得提前安装好 Docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure><h2 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h2><p>我现在部署的一些 App：</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271825038.png" loading="lazy"></p><h3 id="go-import-redirector"><a href="#go-import-redirector" class="headerlink" title="go-import-redirector"></a>go-import-redirector</h3><p>Golang 导包的重定向器，在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JzYy9nby1pbXBvcnQtcmVkaXJlY3Rvcg==">开源<i class="fa fa-external-link-alt"></i></span>的基础上做了点改造</p><p>能把 <code>go get</code> 从自定义域名重定向到 GitHub：</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271833111.png" loading="lazy"></p><p>或者浏览器直接打开，跳转到 GoDoc：</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271830848.png" loading="lazy"></p><h3 id="tinyurl"><a href="#tinyurl" class="headerlink" title="tinyurl"></a>tinyurl</h3><p>自己写的短链接工具，没啥高级功能，<strong>能跑就行</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly90LmNoZW5zbC5tZS9sYzEwMTY=">t.chensl.me&#x2F;lc1016<i class="fa fa-external-link-alt"></i></span></p><h3 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h3><p>Docker 的 Web 界面，结合着 CapRover 用来管理容器</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271855823.png" loading="lazy"></p><h3 id="Syncthing"><a href="#Syncthing" class="headerlink" title="Syncthing"></a>Syncthing</h3><p>一个去中心化的文件同步工具，经常需要用它和室友互传一些文件（😈 不可告人的文件）</p><h3 id="FileBrowser"><a href="#FileBrowser" class="headerlink" title="FileBrowser"></a>FileBrowser</h3><p>结合 Syncthing 使用，在没有安装 Syncthing 的电脑上也能在线管理文件</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271901985.png" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 &lt;code&gt;nohup&lt;/code&gt;, &lt;code&gt;systemd&lt;/code&gt; 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 &lt;code&gt;ssh&lt;/code&gt; 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...&lt;/p&gt;</summary>
    
    
    
    <category term="VPS" scheme="https://blog.zcchub.xyz/categories/VPS/"/>
    
    
    <category term="Vultr" scheme="https://blog.zcchub.xyz/tags/Vultr/"/>
    
    <category term="PaaS" scheme="https://blog.zcchub.xyz/tags/PaaS/"/>
    
    <category term="Heroku" scheme="https://blog.zcchub.xyz/tags/Heroku/"/>
    
    <category term="Dokku" scheme="https://blog.zcchub.xyz/tags/Dokku/"/>
    
    <category term="self-hosted" scheme="https://blog.zcchub.xyz/tags/self-hosted/"/>
    
    <category term="CapRover" scheme="https://blog.zcchub.xyz/tags/CapRover/"/>
    
  </entry>
  
  <entry>
    <title>堆叠文件系统 OverlayFS</title>
    <link href="https://blog.zcchub.xyz/cloud/overlayfs/"/>
    <id>https://blog.zcchub.xyz/cloud/overlayfs/</id>
    <published>2021-10-24T05:12:42.000Z</published>
    <updated>2022-04-02T14:48:25.445Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。</p><span id="more"></span><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NzcwMzMxL2FydGljbGUvZGV0YWlscy85NjY5OTM4Ng==">深入理解 overlayfs<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvb3ZlcmxheWZzLmh0bWw=">Linux Kernel documentation<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>VirtualBox</li><li>Vagrant</li></ul><p>用 vagrant 跑一个带有 docker 的虚拟机：</p><figure class="highlight rb"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$script</span> = <span class="string">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class="line"><span class="string">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">sudo apt-get -y update</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class="line"><span class="string">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class="line"><span class="string">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class="line"><span class="string">sudo apt-get -y update</span></span><br><span class="line"><span class="string">sudo apt-get -y install docker-ce</span></span><br><span class="line"><span class="string">sudo mkdir -p /etc/docker</span></span><br><span class="line"><span class="string">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">sudo systemctl daemon-reload</span></span><br><span class="line"><span class="string">sudo systemctl restart docker</span></span><br><span class="line"><span class="string">sudo systemctl enable docker</span></span><br><span class="line"><span class="string"># Make sure we can actually use docker as the vagrant user</span></span><br><span class="line"><span class="string">sudo usermod -aG docker vagrant</span></span><br><span class="line"><span class="string">sudo docker --version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sudo apt-get -y install bash-completion tree</span></span><br><span class="line"><span class="string">SCRIPT</span></span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">  config.vm.box = <span class="string">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class="line">  config.vm.synced_folder <span class="string">&quot;.&quot;</span>, <span class="string">&quot;/vagrant&quot;</span>, <span class="symbol">disabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, <span class="symbol">inline:</span> <span class="variable">$script</span>, <span class="symbol">privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p>随便拉一个镜像：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vagrant@vagrant:~$ docker pull alpine</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/alpine</span><br><span class="line">a0d0a0d46f8b: Pull complete</span><br><span class="line">Digest: sha256:e1c082e3d3c45cccac829840a25941e679c25d438cc8412c2fa221cf1a824e6a</span><br><span class="line">Status: Downloaded newer image for alpine:latest</span><br><span class="line">docker.io/library/alpine:latest</span><br></pre></td></tr></table></figure><p>这时，我们就能在磁盘上找到对应的目录结构：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vagrant@vagrant:~$ sudo su</span><br><span class="line"></span><br><span class="line">root@vagrant:/home/vagrant# cd /var/lib/docker/overlay2/</span><br><span class="line"></span><br><span class="line">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class="line">ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc  l</span><br><span class="line"></span><br><span class="line">root@vagrant:/var/lib/docker/overlay2# ls ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc/diff/</span><br><span class="line">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>再开一个窗口，启动一个容器：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vagrant@vagrant:~$ docker run --rm -it alpine sh</span><br><span class="line">/ # ls</span><br><span class="line">bin    etc    lib    mnt    proc   run    srv    tmp    var</span><br><span class="line">dev    home   media  opt    root   sbin   sys    usr</span><br></pre></td></tr></table></figure><p>宿主机上的 overlay2 目录多出了一些东西：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class="line">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6       ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc</span><br><span class="line">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6-init  l</span><br><span class="line"></span><br><span class="line">root@vagrant:/var/lib/docker/overlay2# mount | grep overlay</span><br><span class="line">overlay on /var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6ND2PL2RECUKJ3KFZYGPYCA564:/var/lib/docker/overlay2/l/FDPTXFIRIH3NAJ6N5KIKDUMC6O,upperdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/diff,workdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/work)</span><br><span class="line"></span><br><span class="line">root@vagrant:/var/lib/docker/overlay2# ls 7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged/</span><br><span class="line">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>一个名为 <code>overlay</code> 的驱动挂载到了 <code>/var/lib/docker/overlay2/7fca3.../merged</code>，从挂载信息可以看出 merged 目录是由多个目录联合挂载而成，lowerdir 为只读层 (ro)，upperdir 为可读可写层 (rw)，当需要修改 lowerdir 中的文件时，fs 会采用<strong>写时复制</strong>的策略，将文件从 lowerdir 复制到 upperdir 进行修改。在 merged 目录中（或者说在 docker 容器中）是感知不到这些复杂逻辑的，和操作正常目录没有区别</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161306717.jpeg" loading="lazy"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>大概了解了 OverlayFS 之后，我们抛开 Docker 仅仅用 Linux 命令行就能模拟出一个简单的容器（注意只是简单模拟，几乎谈不上什么隔离性）</p><p>在开始前可以切换到 root，免得不必要的麻烦</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><h3 id="制作基础-rootfs"><a href="#制作基础-rootfs" class="headerlink" title="制作基础 rootfs"></a>制作基础 rootfs</h3><p>最后利用一下 Docker，导出一个 alpine 的 rootfs：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs &amp;&amp; docker <span class="built_in">export</span> $(docker create alpine) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure><h3 id="Lowerdirs"><a href="#Lowerdirs" class="headerlink" title="Lowerdirs"></a>Lowerdirs</h3><p>由于 lowerdir 可以配置多个，所以，我们可以利用这一特性对 rootfs 进行一些定制。</p><p>替换中科大源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p rootfs-init/etc/apk</span><br><span class="line"><span class="built_in">cp</span> rootfs/etc/apk/repositories rootfs-init/etc/apk/</span><br><span class="line">sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> rootfs-init/etc/apk/repositories</span><br></pre></td></tr></table></figure><p>配置 DNS：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;nameserver 223.5.5.5&#x27;</span> &gt; rootfs-init/etc/resolv.conf</span><br></pre></td></tr></table></figure><h3 id="准备其他目录"><a href="#准备其他目录" class="headerlink" title="准备其他目录"></a>准备其他目录</h3><p>创建 upperdir，workdir 和 merged</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> diff work merged</span><br></pre></td></tr></table></figure><p>最终的目录结构：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@vagrant:~# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── diff</span><br><span class="line">├── merged</span><br><span class="line">├── rootfs</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── dev</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── home</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── media</span><br><span class="line">│   ├── mnt</span><br><span class="line">│   ├── opt</span><br><span class="line">│   ├── proc</span><br><span class="line">│   ├── root</span><br><span class="line">│   ├── run</span><br><span class="line">│   ├── sbin</span><br><span class="line">│   ├── srv</span><br><span class="line">│   ├── sys</span><br><span class="line">│   ├── tmp</span><br><span class="line">│   ├── usr</span><br><span class="line">│   └── var</span><br><span class="line">├── rootfs-init</span><br><span class="line">│   └── etc</span><br><span class="line">└── work</span><br><span class="line"></span><br><span class="line">23 directories, 0 files</span><br></pre></td></tr></table></figure><h3 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h3><p>将准备好的目录挂在到 merged:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount overlay -t overlay -o lowerdir=/root/rootfs-init:/root/rootfs,upperdir=/root/diff,workdir=/root/work /root/merged</span><br></pre></td></tr></table></figure><h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>利用 chroot 改变根文件系统</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> merged</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> apk update</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> apk upgrade</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> apk add gcc</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> gcc -v</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> apk add neofetch</span><br><span class="line"><span class="built_in">chroot</span> <span class="variable">$PWD</span> neofetch</span><br></pre></td></tr></table></figure><p>至此，我们已经通过 OverlayFS 和 chroot 实现了一个简易的容器</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@vagrant:~# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── diff</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── dev</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── root</span><br><span class="line">│   ├── usr</span><br><span class="line">│   └── var</span><br><span class="line">├── merged</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── dev</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── home</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── media</span><br><span class="line">│   ├── mnt</span><br><span class="line">│   ├── opt</span><br><span class="line">│   ├── proc</span><br><span class="line">│   ├── root</span><br><span class="line">│   ├── run</span><br><span class="line">│   ├── sbin</span><br><span class="line">│   ├── srv</span><br><span class="line">│   ├── sys</span><br><span class="line">│   ├── tmp</span><br><span class="line">│   ├── usr</span><br><span class="line">│   └── var</span><br><span class="line">├── rootfs</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── dev</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── home</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── media</span><br><span class="line">│   ├── mnt</span><br><span class="line">│   ├── opt</span><br><span class="line">│   ├── proc</span><br><span class="line">│   ├── root</span><br><span class="line">│   ├── run</span><br><span class="line">│   ├── sbin</span><br><span class="line">│   ├── srv</span><br><span class="line">│   ├── sys</span><br><span class="line">│   ├── tmp</span><br><span class="line">│   ├── usr</span><br><span class="line">│   └── var</span><br><span class="line">├── rootfs-init</span><br><span class="line">│   └── etc</span><br><span class="line">└── work</span><br><span class="line">    └── work</span><br><span class="line"></span><br><span class="line">48 directories, 0 files</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://blog.zcchub.xyz/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="Linux" scheme="https://blog.zcchub.xyz/tags/Linux/"/>
    
    <category term="Docker" scheme="https://blog.zcchub.xyz/tags/Docker/"/>
    
    <category term="OverlayFS" scheme="https://blog.zcchub.xyz/tags/OverlayFS/"/>
    
    <category term="chroot" scheme="https://blog.zcchub.xyz/tags/chroot/"/>
    
  </entry>
  
  <entry>
    <title>使用 Vagrant 搭建开发环境</title>
    <link href="https://blog.zcchub.xyz/tool/vagrant/"/>
    <id>https://blog.zcchub.xyz/tool/vagrant/</id>
    <published>2021-10-12T08:02:32.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建<strong>一次性</strong>使用的开发环境时真的非常非常方便</p><span id="more"></span><h2 id="需要安装的工具"><a href="#需要安装的工具" class="headerlink" title="需要安装的工具"></a>需要安装的工具</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudmlydHVhbGJveC5vcmcv">VirtualBox<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS8=">Vagrant<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>更具体的推荐看<span class="exturl" data-url="aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS9kb2Nz">官方文档<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant init bento/ubuntu-18.04 <span class="comment"># 创建配置文件并指定 box</span></span><br><span class="line">vagrant up                      <span class="comment"># 开机</span></span><br><span class="line">vagrant reload                  <span class="comment"># 重启（重新加载配置）</span></span><br><span class="line">vagrant halt                    <span class="comment"># 关机</span></span><br><span class="line">vagrant destroy                 <span class="comment"># 销毁虚拟机</span></span><br><span class="line">vagrant box list                <span class="comment"># 显示已下载的 box</span></span><br><span class="line"></span><br><span class="line">vagrant <span class="built_in">suspend</span>                 <span class="comment"># 暂停</span></span><br><span class="line">vagrant resume                  <span class="comment"># 恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 box，具体看 vagrant box add -h</span></span><br><span class="line">vagrant box add [options] &lt;name, url, or path&gt;</span><br><span class="line">vagrant box remove &lt;name&gt; <span class="comment"># 删除 box</span></span><br></pre></td></tr></table></figure><h3 id="box"><a href="#box" class="headerlink" title="box"></a>box</h3><p>按照传统方法，装一台虚拟机，必须去某个 Linux 发行版的官网上下载 ISO 文件，然后打开 VMware 或者 VirtualBox，使用 ISO 一步一步创建虚拟机。而 Vagrant 提供了更简单的形式，一条命令就能从 box 创建并启动虚拟机</p><p>可以在官网<span class="exturl" data-url="aHR0cHM6Ly9hcHAudmFncmFudHVwLmNvbS9ib3hlcy9zZWFyY2g=">搜索<i class="fa fa-external-link-alt"></i></span>现成的 box</p><h3 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h3><p>相当于虚拟机的配置文件，可以配置网络、内存、CPU、同步文件夹、端口映射等，使用 <code>vagrant init</code> 在当前目录创建配置模板</p><p>一个最简单的配置文件就是仅指定 box，其他默认：</p><figure class="highlight rb"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">  config.vm.box = <span class="string">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接着 <code>vagrant up</code> 读取配置文件并运行虚拟机，然后就可以去泡杯咖啡，其他什么也不用管，一切交给 vagrant（前提是网络环境好的情况下，懂得都懂，怎么保证访问外网的速度 🧱），当不再需要的时候运行 <code>vagrant destroy</code> 销毁即可。</p><h2 id="更复杂的配置"><a href="#更复杂的配置" class="headerlink" title="更复杂的配置"></a>更复杂的配置</h2><p>以最近自己用的 golang + docker 环境为例，其实主要部分就是一个 shell 脚本，然后配置了私有网络，修改硬件为 1 CPU 2G 内存</p><p>shell 脚本默认情况下只会在第一次 <code>vagrant up</code> 的时候执行</p><figure class="highlight rb"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$script</span> = <span class="string">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class="line"><span class="string">echo &quot;Setting timezone to Asia/Shanghai...&quot;</span></span><br><span class="line"><span class="string">sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="string">echo &quot;Asia/Shanghai&quot; | sudo tee /etc/timezone</span></span><br><span class="line"><span class="string">date</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo &quot;Using Aliyun mirrors...&quot;</span></span><br><span class="line"><span class="string">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">sudo apt-get update</span></span><br><span class="line"><span class="string"># Comment apt upgrade to make vagrant up faster</span></span><br><span class="line"><span class="string"># sudo apt-get -y upgrade</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo &quot;Installing Docker...&quot;</span></span><br><span class="line"><span class="string">sudo apt-get remove docker docker-engine docker.io</span></span><br><span class="line"><span class="string">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class="line"><span class="string">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class="line"><span class="string">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class="line"><span class="string">sudo apt-get -y update</span></span><br><span class="line"><span class="string">sudo apt-get -y install docker-ce</span></span><br><span class="line"><span class="string">sudo mkdir -p /etc/docker</span></span><br><span class="line"><span class="string">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">sudo systemctl daemon-reload</span></span><br><span class="line"><span class="string">sudo systemctl restart docker</span></span><br><span class="line"><span class="string">sudo systemctl enable docker</span></span><br><span class="line"><span class="string"># Make sure we can actually use docker as the vagrant user</span></span><br><span class="line"><span class="string">sudo usermod -aG docker vagrant</span></span><br><span class="line"><span class="string">sudo docker --version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo &quot;Installing Golang...&quot;</span></span><br><span class="line"><span class="string">GO_VERSION=1.17.2</span></span><br><span class="line"><span class="string">curl -sSL https://gomirrors.org/dl/go/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz -o /tmp/go.tgz</span></span><br><span class="line"><span class="string">sudo rm -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf /tmp/go.tgz</span></span><br><span class="line"><span class="string">tee -a /home/vagrant/.profile &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">export GOROOT=/usr/local/go</span></span><br><span class="line"><span class="string">export GOPATH=/home/vagrant/go</span></span><br><span class="line"><span class="string">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">source /home/vagrant/.profile</span></span><br><span class="line"><span class="string">go version</span></span><br><span class="line"><span class="string">go env -w GO111MODULE=on</span></span><br><span class="line"><span class="string">go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct</span></span><br><span class="line"><span class="string">mkdir -p /home/vagrant/go/&#123;bin,pkg,src&#125;</span></span><br><span class="line"><span class="string">SCRIPT</span></span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">  config.vm.box = <span class="string">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class="line">  config.vm.network <span class="string">&quot;private_network&quot;</span>, <span class="symbol">ip:</span> <span class="string">&quot;192.168.33.11&quot;</span></span><br><span class="line"></span><br><span class="line">  config.vm.provider <span class="string">&quot;virtualbox&quot;</span> <span class="keyword">do</span> |<span class="params">vb</span>|</span><br><span class="line">    vb.cpus = <span class="string">&quot;1&quot;</span></span><br><span class="line">    vb.memory = <span class="string">&quot;2048&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, <span class="symbol">inline:</span> <span class="variable">$script</span>, <span class="symbol">privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建&lt;strong&gt;一次性&lt;/strong&gt;使用的开发环境时真的非常非常方便&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="https://blog.zcchub.xyz/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Vagrant" scheme="https://blog.zcchub.xyz/tags/Vagrant/"/>
    
    <category term="VirtualBox" scheme="https://blog.zcchub.xyz/tags/VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>开始第一个 Pull Request</title>
    <link href="https://blog.zcchub.xyz/github/first-pr/"/>
    <id>https://blog.zcchub.xyz/github/first-pr/</id>
    <published>2021-09-18T07:52:39.000Z</published>
    <updated>2022-04-02T14:48:25.445Z</updated>
    
    <content type="html"><![CDATA[<p>git 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。</p><span id="more"></span><h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><blockquote><p>GitHub 简单的使用就不赘述了，这篇主要分享一下我是怎么从一个人默默玩“单机版 GitHub”，到第一次给别人的项目提交 pr</p></blockquote><p>首先，什么是 pr (pull request) ？在本地使用 git 的时候，有一个 merge 功能，能够进行分支合并，pr 就是 GitHub 上的 merge，它增加了代码 review 和 CI&#x2F;CD 等功能。通过 pr 我们可以给别人的项目新增功能、修复 bug，在项目维护者 review 完你的代码，通过并且合并了这次 pr，你就能成为这个项目的 contributor (贡献者)</p><h2 id="我的第一次-PR"><a href="#我的第一次-PR" class="headerlink" title="我的第一次 PR"></a>我的第一次 PR</h2><p>玩 GitHub 的程序员肯定多多少少希望自己的仓库能有很多 ⭐，我也不例外，但是无奈技术还没达到大佬的级别，写不出什么好的项目或者框架。一次逛 GitHub 发现别人整理的力扣热门问题的 Go 语言题解，获得了挺多星星，于是就想自己也整理一个 Java 版本的。但也是三分热度，写了几周就没坚持下去，后来偶然看到了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmdsYm1l">杨立滨<i class="fa fa-external-link-alt"></i></span>大佬维护的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2Rl">doocs&#x2F;leetcode<i class="fa fa-external-link-alt"></i></span>，被 README 里的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlIyVFNSU4QSVBMCVFNSU4NSVBNSVFNiU4OCU5MSVFNCVCQiVBQw==">加入我们<i class="fa fa-external-link-alt"></i></span>吸引到了：</p><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161308204.png" loading="lazy"></p><p>迈出第一步确实挺紧张，查了好多资料，然后照着 README 里的步骤打开了人生第一次 pr (<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlL3B1bGwvMzU5">#359<i class="fa fa-external-link-alt"></i></span>)，虽然有些错误，但是在大佬的指点下还是改正了过来，成功被合并。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>自己的一些小经验，一次规范的 pr 不仅减少了自己重复修改的次数，也方便了项目维护者 review</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>可能每个人都有自己的编程习惯，左大括号换行或是不换行，2 空格缩进或是 4 空格缩进。自己敲代码的时候可以按习惯来，但是在提交前最好按照项目的标准格式化一遍（自己配置好格式化工具或者使用项目提供的格式化配置）</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>项目有单元测试，修改了代码后，确保单元测试跑的通，不要提交一个显而易见的 bug。如果是文档类项目，最好在本地预览一遍（除非你很熟练，相信自己不会在 markdown 里都写出 bug）</p><h3 id="Commit-Message"><a href="#Commit-Message" class="headerlink" title="Commit Message"></a>Commit Message</h3><p>大部分项目对 commit message 会有一定要求，可以学习一下 Angular 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIuNi9DT05UUklCVVRJTkcubWQjY29tbWl0">Commit Message Format<i class="fa fa-external-link-alt"></i></span>。另外可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbW1pdGl6ZW4vY3otY2xp">cz-cli<i class="fa fa-external-link-alt"></i></span> 很方便地写出规范的 commit message:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 cz-cli (前提得先装好 node.js)</span></span><br><span class="line">npm i -g commitizen cz-conventional-changelog</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27;</span> &gt; ~/.czrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 像往常一样 add 然后 commit (commit 改为 cz)</span></span><br><span class="line">git add .</span><br><span class="line">git cz</span><br></pre></td></tr></table></figure><p>没人不喜欢这样清晰的 commits:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">007059963 (HEAD -&gt; main, origin/main, origin/HEAD) feat: add solutions to lc/lcof2 problem: Asteroid Collision</span><br><span class="line">92e73c337 chore: update contributors to @doocs/leetcode</span><br><span class="line">8453df21d feat: add solutions to lc problem: No.0825.Friends Of Appropriate Ages</span><br><span class="line">f8ea6eb9d feat: add solutions to lcof2 problem:No.075</span><br><span class="line">362159f22 feat: add solutions to lc problems: No.0912,1122</span><br><span class="line">89d6e7117 feat: add solutions to lc problem: No.1869.Longer Contiguous Segments of Ones than Zeros</span><br><span class="line">b680b612c feat: add solutions to lc problem: No.1051.Height Checker</span><br><span class="line">f4ccd19bd feat: add solutions to lc problem: No.0912.Sort an Array</span><br><span class="line">2e803a22b feat: add solutions to lcof2 problem: No.046</span><br><span class="line">6421c40d3 chore: update contributors to @doocs/leetcode</span><br><span class="line">f41bad246 feat: add cpp solution to lcof2 problem: NO.046 (<span class="comment">#567)</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>打一波广告，欢迎喜欢刷题的小伙伴加入我们</p><p><a href="https://github.com/doocs/leetcode"><img data-src="https://github-readme-stats.vercel.app/api/pin/?username=doocs&repo=leetcode&show_owner=true" alt="leetcode" loading="lazy"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;git 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。&lt;/p&gt;</summary>
    
    
    
    <category term="GitHub" scheme="https://blog.zcchub.xyz/categories/GitHub/"/>
    
    
    <category term="LeetCode" scheme="https://blog.zcchub.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>熔断器模式</title>
    <link href="https://blog.zcchub.xyz/golang/gobreaker/"/>
    <id>https://blog.zcchub.xyz/golang/gobreaker/</id>
    <published>2021-09-16T08:21:28.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。</p><h2 id="背景和问题"><a href="#背景和问题" class="headerlink" title="背景和问题"></a>背景和问题</h2><p>在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。</p><p>此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是<strong>立即</strong>让调用失败，只有在可能成功时才尝试调用服务。</p><span id="more"></span><div class="note warning"><p>设置一个更短的超时可能有助于解决这个问题，但是超时不应该太短，这可能会让那些本来应该成功的请求也超时。</p></div><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>熔断器作为一个可能失败操作的代理，监控最近发生故障的数量，然后使用这些信息来决定是否允许操作继续，防止应用程序反复执行失败操作。</p><p>熔断器本质上就是一个<strong>状态机</strong>，它具有以下状态：</p><ul><li><strong>Closed：</strong>程序可以正常发出请求，熔断器维护最近失败的次数，如果操作调用不成功，则熔断器增加此计数。如果在给定时间内，失败次数超过了指定的阈值，状态机将变为 <strong>Open</strong> 状态。此时，启动一个计时器，在一定时间后，状态机变为 <strong>Half-Open</strong> 状态。</li><li><strong>Open：</strong>程序发出的请求会立即失败，并向程序返回异常。（相当于电闸跳闸了）</li><li><strong>Half-Open：</strong>程序只能执行有限数量的请求操作，如果这些请求成功了（故障已经恢复），状态机变为 <strong>Closed</strong> 状态。如果请求失败了，状态机变为 <strong>Open</strong> 状态，并且重新启动计时器。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161309094.png" loading="lazy"></p><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><p><a href="https://github.com/sony/gobreaker"><img data-src="https://github-readme-stats.vercel.app/api/pin/?username=sony&repo=gobreaker&show_owner=true" alt="gobreaker" loading="lazy"></a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们可以通过 <code>Settings</code> 结构体配置熔断器：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Settings <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name          <span class="type">string</span></span><br><span class="line">    MaxRequests   <span class="type">uint32</span></span><br><span class="line">    Interval      time.Duration</span><br><span class="line">    Timeout       time.Duration</span><br><span class="line">    ReadyToTrip   <span class="function"><span class="keyword">func</span><span class="params">(counts Counts)</span></span> <span class="type">bool</span></span><br><span class="line">    OnStateChange <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, from State, to State)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>MaxRequests</code>: <strong>Half-Open</strong> 状态下的最大请求次数，默认为 1</li><li><code>Interval</code>: <strong>Closed</strong> 状态下清空计数器的周期，默认不清空</li><li><code>Timeout</code>: <strong>Open</strong> 状态转 <strong>Half-Open</strong> 状态的时间，默认 60 秒</li><li><code>ReadyToTrip</code>: 通过计数器的信息判断是否需要熔断，默认连续失败 5 次后熔断</li><li><code>OnStateChange</code>: 状态变化时的回调</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;</span><br><span class="line">        ReadyToTrip: <span class="function"><span class="keyword">func</span><span class="params">(counts gobreaker.Counts)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            failureRatio := <span class="type">float64</span>(counts.TotalFailures) / <span class="type">float64</span>(counts.Requests)</span><br><span class="line">            <span class="comment">// 失败率大于 60% 时熔断</span></span><br><span class="line">            <span class="keyword">return</span> counts.Requests &gt;= <span class="number">3</span> &amp;&amp; failureRatio &gt;= <span class="number">0.6</span></span><br><span class="line">        &#125;,</span><br><span class="line">        OnStateChange: <span class="function"><span class="keyword">func</span><span class="params">(_ <span class="type">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;from: %v, to: %v\n&quot;</span>, from, to)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        result, err := cb.Execute(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="comment">// 模拟 70% 的失败率</span></span><br><span class="line">            <span class="keyword">if</span> rand.Float64() &lt; <span class="number">0.7</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;some error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">        log.Printf(<span class="string">&quot;result: %v, err: %v\n&quot;</span>, result, err)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2021/09/16 15:23:24 result: &lt;nil&gt;, err: some error</span><br><span class="line">2021/09/16 15:23:25 result: &lt;nil&gt;, err: some error</span><br><span class="line">2021/09/16 15:23:26 from: closed, to: open</span><br><span class="line">2021/09/16 15:23:26 result: &lt;nil&gt;, err: some error</span><br><span class="line">2021/09/16 15:23:27 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class="line">2021/09/16 15:23:28 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class="line">2021/09/16 15:23:29 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class="line">2021/09/16 15:23:30 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="Execute-流程"><a href="#Execute-流程" class="headerlink" title="Execute 流程"></a>Execute 流程</h3><p>简单过一遍 <code>Execute()</code> 的流程，详细代码可以看 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2VyL2Jsb2IvbWFzdGVyL2dvYnJlYWtlci5nbw==">gobreader.go<i class="fa fa-external-link-alt"></i></span>，不到 400 行，实现的非常简洁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span></span> Execute(req <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 增加计数，判断状态</span></span><br><span class="line">    generation, err := cb.beforeRequest()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果熔断器已经 Open，在这里就会直接返回 ErrOpenState</span></span><br><span class="line">        <span class="comment">// Half-Open 状态下超过最大请求数则返回 ErrTooManyRequests</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        e := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            cb.afterRequest(generation, <span class="literal">false</span>)</span><br><span class="line">            <span class="built_in">panic</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行真正的操作</span></span><br><span class="line">    result, err := req()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数，达到阈值就熔断，err 非空表示失败</span></span><br><span class="line">    cb.afterRequest(generation, err == <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码，我们可以看出，执行过程只是简单地通过 <code>err == nil</code> 判断成功，假设业务的逻辑很复杂，需要加入自定义的判断，可以用 <code>TwoStepCircuitBreaker</code>。</p><h3 id="两阶段熔断"><a href="#两阶段熔断" class="headerlink" title="两阶段熔断"></a>两阶段熔断</h3><p>和普通熔断器的使用差不多，<code>Allow()</code> 方法只是调用了 <code>beforeRequest()</code>，然后返回回调函数 <code>done(success bool)</code> 和错误信息，通过回调函数我们能把操作成功与否告诉熔断器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    cb := gobreaker.NewTwoStepCircuitBreaker(gobreaker.Settings&#123;</span><br><span class="line">        ReadyToTrip: <span class="function"><span class="keyword">func</span><span class="params">(counts gobreaker.Counts)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            failureRatio := <span class="type">float64</span>(counts.TotalFailures) / <span class="type">float64</span>(counts.Requests)</span><br><span class="line">            <span class="keyword">return</span> counts.Requests &gt;= <span class="number">3</span> &amp;&amp; failureRatio &gt;= <span class="number">0.6</span></span><br><span class="line">        &#125;,</span><br><span class="line">        OnStateChange: <span class="function"><span class="keyword">func</span><span class="params">(_ <span class="type">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;from: %v, to: %v\n&quot;</span>, from, to)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        done, err := cb.Allow()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;err: %v\n&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        success := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> rand.Float64() &lt; <span class="number">0.7</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;failure&quot;</span>)</span><br><span class="line">            success = <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        done(success)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2021/09/16 16:26:49 failure</span><br><span class="line">2021/09/16 16:26:50 failure</span><br><span class="line">2021/09/16 16:26:51 success</span><br><span class="line">2021/09/16 16:26:52 failure</span><br><span class="line">2021/09/16 16:26:52 from: closed, to: open</span><br><span class="line">2021/09/16 16:26:53 err: circuit breaker is open</span><br><span class="line">2021/09/16 16:26:54 err: circuit breaker is open</span><br><span class="line">2021/09/16 16:26:55 err: circuit breaker is open</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvbXNwLW4tcC9kbjU4OTc4NCh2PXBhbmRwLjEwKQ==">Circuit Breaker Pattern<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2Vy">gobreaker<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。&lt;/p&gt;
&lt;h2 id=&quot;背景和问题&quot;&gt;&lt;a href=&quot;#背景和问题&quot; class=&quot;headerlink&quot; title=&quot;背景和问题&quot;&gt;&lt;/a&gt;背景和问题&lt;/h2&gt;&lt;p&gt;在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。&lt;/p&gt;
&lt;p&gt;此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是&lt;strong&gt;立即&lt;/strong&gt;让调用失败，只有在可能成功时才尝试调用服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.zcchub.xyz/categories/Golang/"/>
    
    
    <category term="微服务" scheme="https://blog.zcchub.xyz/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>高性能字节池 - bytebufferpool 源码分析</title>
    <link href="https://blog.zcchub.xyz/golang/bytebufferpool/"/>
    <id>https://blog.zcchub.xyz/golang/bytebufferpool/</id>
    <published>2021-06-28T08:19:02.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天的主角是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2w=">bytebufferpool<i class="fa fa-external-link-alt"></i></span> ，仓库的 README 文件是这么描述 bytebufferpool 的：</p><blockquote><p>Currently bytebufferpool is fastest and most effective buffer pool written in Go.</p></blockquote><span id="more"></span><p>bytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvZmFzdGh0dHA=">fasthttp<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvcXVpY2t0ZW1wbGF0ZQ==">quicktemplate<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhbmpmMjAwMC9nbmV0">gnet<i class="fa fa-external-link-alt"></i></span>）</p><p>什么是字节池？在读取文件或者从 <code>io.Reader</code> 获取数据时，一般都需要创建一个字节切片 <code>[]byte</code> 作为缓冲，如果对于这种方法有大量的调用，就会频繁地创建 <code>[]byte</code> ，这需要太多内存的申请和释放，增大了 GC 的压力。这个时候“池化”技术就派上了用场，通过复用对象以减少内存的分配和释放。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, _ := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">    <span class="comment">// 普通方式</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(<span class="type">string</span>(buf[:n]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><h3 id="MinIO-BytePoolCap"><a href="#MinIO-BytePoolCap" class="headerlink" title="MinIO BytePoolCap"></a>MinIO BytePoolCap</h3><p>MinIO 中使用 <code>channel</code> 实现了一个非常简单的<strong>有界</strong>字节池 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pbmlvL21pbmlvL2Jsb2IvbWFzdGVyL2ludGVybmFsL2Jwb29sL2Jwb29sLmdv">bpool<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BytePoolCap <span class="keyword">struct</span> &#123;</span><br><span class="line">    c    <span class="keyword">chan</span> []<span class="type">byte</span></span><br><span class="line">    w    <span class="type">int</span></span><br><span class="line">    wcap <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBytePoolCap</span><span class="params">(maxSize <span class="type">int</span>, width <span class="type">int</span>, capwidth <span class="type">int</span>)</span></span> (bp *BytePoolCap) &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BytePoolCap&#123;</span><br><span class="line">        c:    <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">byte</span>, maxSize),</span><br><span class="line">        w:    width,</span><br><span class="line">        wcap: capwidth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>c</code> 用来存放字节切片（这也就是为什么<strong>有界</strong>的原因）</li><li><code>w</code> 表示创建字节切片的 <code>len</code></li><li><code>wcap</code> 表示创建字节切片的 <code>cap</code></li></ul><p><code>Get()</code> 方法, 从池中获取字节切片：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bp *BytePoolCap)</span></span> Get() (b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b = &lt;-bp.c:</span><br><span class="line">        <span class="comment">// channel 中存在 []byte 则复用</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 否则创建 []byte</span></span><br><span class="line">        <span class="keyword">if</span> bp.wcap &gt; <span class="number">0</span> &#123;</span><br><span class="line">            b = <span class="built_in">make</span>([]<span class="type">byte</span>, bp.w, bp.wcap)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = <span class="built_in">make</span>([]<span class="type">byte</span>, bp.w)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Put([]byte)</code> 方法，将使用完的切片放回池中，以被下一次获取：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bp *BytePoolCap)</span></span> Put(b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> bp.c &lt;- b:</span><br><span class="line">        <span class="comment">// channel 放得下</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// channel 放不下的话则不进行任何操作，直接丢弃这个 []byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个 goroutine 公用一个 pool</span></span><br><span class="line"><span class="keyword">var</span> bp = bpool.NewBytePoolCap(<span class="number">100</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func ...</span></span><br><span class="line">buf := bp.Get()</span><br><span class="line"><span class="keyword">defer</span> bp.Put(buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use buf ...</span></span><br></pre></td></tr></table></figure><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><p>谈到“池”，很容易想到 Go 标准库中的 <code>sync.Pool</code>，我们可以用几行代码就实现一个简单的字节池：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool := &amp;sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用 <code>pool.Get().([]byte)</code> 从池中取字节切片，使用完后调用 <code>pool.Put(buf)</code> 归还到池中。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>上面的两种字节池实现都存在许多问题：池中新建的字节切片的 <code>len</code> 和 <code>cap</code> 都是创建池的时候固定的，不能动态修改。另外，如果往字节切片写入了大量数据（发生多次扩容），此时再将这样的字节切片放回池中，显然会造成内存浪费。</p><p>所以需要解决的问题：</p><ol><li>动态修改新分配字节切片的大小</li><li>阻止大切片放回字节池</li></ol><h2 id="ByteBufferPool"><a href="#ByteBufferPool" class="headerlink" title="ByteBufferPool"></a>ByteBufferPool</h2><p>ByteBufferPool 中实现了一个类似 <code>bytes.Buffer</code> 的结构（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2wvYmxvYi9tYXN0ZXIvYnl0ZWJ1ZmZlci5nbw==">ByteBuffer<i class="fa fa-external-link-alt"></i></span>），它封装了一些对 <code>[]byte</code> 的复杂操作，从 benchmark 的结果可以看出它的性能比 <code>bytes.Buffer</code> 略高一些，但它不是字节池的重点，所以就不贴代码了。</p><p>ByteBufferPool 是怎么解决上述问题的？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    minBitSize = <span class="number">6</span>  <span class="comment">// 2**6=64 is a CPU cache line size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 buf 的大小划分为 20 个区间</span></span><br><span class="line">    <span class="comment">// ==&gt; (0, 64], (64, 128], (128, 256], ... , (8388608, 16777216], (16777216, 33554432]</span></span><br><span class="line">    <span class="comment">// 超过 33554432 的也属于最后一个区间</span></span><br><span class="line">    steps = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    minSize = <span class="number">1</span> &lt;&lt; minBitSize               <span class="comment">// 64</span></span><br><span class="line">    maxSize = <span class="number">1</span> &lt;&lt; (minBitSize + steps - <span class="number">1</span>) <span class="comment">// 33554432</span></span><br><span class="line"></span><br><span class="line">    calibrateCallsThreshold = <span class="number">42000</span></span><br><span class="line">    maxPercentile           = <span class="number">0.95</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    calls       [steps]<span class="type">uint64</span> <span class="comment">// 不同大小 buf 的使用频次</span></span><br><span class="line">    calibrating <span class="type">uint64</span>        <span class="comment">// 标记是否正在校准（校准过程就是调整 defaultSize 和 maxSize）</span></span><br><span class="line"></span><br><span class="line">    defaultSize <span class="type">uint64</span> <span class="comment">// make []byte 时的 cap</span></span><br><span class="line">    maxSize     <span class="type">uint64</span> <span class="comment">// 能放回池中的最大 buf 大小</span></span><br><span class="line"></span><br><span class="line">    pool sync.Pool <span class="comment">// 存储 buf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() *ByteBuffer &#123;</span><br><span class="line">    v := p.pool.Get()</span><br><span class="line">    <span class="comment">// 如果池中有 buf 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.(*ByteBuffer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则新建一个 cap 为 defaultSize 的 buf</span></span><br><span class="line">    <span class="keyword">return</span> &amp;ByteBuffer&#123;</span><br><span class="line">        B: <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, atomic.LoadUint64(&amp;p.defaultSize)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看 <code>Put()</code>，从这就可以看出 ByteBufferPool 的主要逻辑了：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(b *ByteBuffer) &#123;</span><br><span class="line">    <span class="comment">// len 所在 “区间” 的下标</span></span><br><span class="line">    idx := index(<span class="built_in">len</span>(b.B))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决了问题1：动态调整 size</span></span><br><span class="line">    <span class="comment">// 使用频次加1，如果超过了阈值（42000）则进行校准</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddUint64(&amp;p.calls[idx], <span class="number">1</span>) &gt; calibrateCallsThreshold &#123;</span><br><span class="line">        p.calibrate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决了问题2：阻止大切片放回字节池</span></span><br><span class="line">    <span class="comment">// 如果还未设置 maxSize 或 cap 小于等于 maxSize 才执行 Put</span></span><br><span class="line">    maxSize := <span class="type">int</span>(atomic.LoadUint64(&amp;p.maxSize))</span><br><span class="line">    <span class="keyword">if</span> maxSize == <span class="number">0</span> || <span class="built_in">cap</span>(b.B) &lt;= maxSize &#123;</span><br><span class="line">        b.Reset()</span><br><span class="line">        p.pool.Put(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n--</span><br><span class="line">    n &gt;&gt;= minBitSize</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        idx++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> idx &gt;= steps &#123;</span><br><span class="line">        idx = steps - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>划分区间的目的就是方便统计出程序近一段时间内<strong>最经常使用</strong>多大的 buf，从而决定 <code>defaultSize</code> 和 <code>maxSize</code>，这一块的逻辑主要在 <code>calibrate()</code> ：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> calibrate() &#123;</span><br><span class="line">    <span class="comment">// 通过 CAS 确保同一时刻只有一个 goroutine 执行 calibrate</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CompareAndSwapUint64(&amp;p.calibrating, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a := <span class="built_in">make</span>(callSizes, <span class="number">0</span>, steps)</span><br><span class="line">    <span class="comment">// 所有大小 buf 的总使用频次</span></span><br><span class="line">    <span class="keyword">var</span> callsSum <span class="type">uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt; steps; i++ &#123;</span><br><span class="line">        calls := atomic.SwapUint64(&amp;p.calls[i], <span class="number">0</span>)</span><br><span class="line">        callsSum += calls</span><br><span class="line">        a = <span class="built_in">append</span>(a, callSize&#123;</span><br><span class="line">            calls: calls,</span><br><span class="line">            size:  minSize &lt;&lt; i,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照使用频次从大到小排序</span></span><br><span class="line">    sort.Sort(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 defaultSize 设置为频次最高的 size</span></span><br><span class="line">    defaultSize := a[<span class="number">0</span>].size</span><br><span class="line">    maxSize := defaultSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 maxSize，让 95% 的 buf 都能被归还到池中，只有最大的 %5 无法归还</span></span><br><span class="line">    maxSum := <span class="type">uint64</span>(<span class="type">float64</span>(callsSum) * maxPercentile)</span><br><span class="line">    callsSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; steps; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> callsSum &gt; maxSum &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        callsSum += a[i].calls</span><br><span class="line">        size := a[i].size</span><br><span class="line">        <span class="keyword">if</span> size &gt; maxSize &#123;</span><br><span class="line">            maxSize = size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 pool 会被多个 goroutine 访问，所以需要使用原子写入</span></span><br><span class="line">    atomic.StoreUint64(&amp;p.defaultSize, defaultSize)</span><br><span class="line">    atomic.StoreUint64(&amp;p.maxSize, maxSize)</span><br><span class="line"></span><br><span class="line">    atomic.StoreUint64(&amp;p.calibrating, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callSize <span class="keyword">struct</span> &#123;</span><br><span class="line">    calls <span class="type">uint64</span> <span class="comment">// 使用频次</span></span><br><span class="line">    size  <span class="type">uint64</span> <span class="comment">// buf 大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callSizeSlice []callSize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a callSizeSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a callSizeSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a callSizeSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].calls &gt; a[j].calls &#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01hb0xvbmdMb25nL2J5dGVidWZmZXJwb29sL2Jsb2IvbWFpbi9wb29sX2JlbmNoX3Rlc3QuZ28=">pool_bench_test.go<i class="fa fa-external-link-alt"></i></span></p><p>从上往下，分别为 ByteBufferPool, MinIO BytePoolCap 和普通 <code>[]byte</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=Pool -benchmem</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/maolonglong/bytebufferpool</span><br><span class="line">cpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz</span><br><span class="line">BenchmarkByteBufferPoolBuf-4    20764896                52.71 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkBPool-4                 7899157               156.4 ns/op             0 B/op          0 allocs/op</span><br><span class="line">BenchmarkWithoutPool-4           4511701               270.5 ns/op          1472 B/op          3 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/maolonglong/bytebufferpool   4.091s</span><br></pre></td></tr></table></figure><p>从测试结果可以看出，ByteBufferPool 不管在速度还是内存上都优于另外两种方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GitHub 上许多优秀的项目其实代码并不难，通过这些项目可以学习大佬们设计、优化代码的思想，提升自己解决实际问题的能力。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;今天的主角是 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2w=&quot;&gt;bytebufferpool&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; ，仓库的 README 文件是这么描述 bytebufferpool 的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Currently bytebufferpool is fastest and most effective buffer pool written in Go.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.zcchub.xyz/categories/Golang/"/>
    
    
    <category term="pool" scheme="https://blog.zcchub.xyz/tags/pool/"/>
    
  </entry>
  
  <entry>
    <title>无锁队列的简单实现</title>
    <link href="https://blog.zcchub.xyz/golang/lock-free-queue/"/>
    <id>https://blog.zcchub.xyz/golang/lock-free-queue/</id>
    <published>2021-06-25T08:16:59.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS91L3Njb3R0L3BhcGVycy8xOTk2X1BPRENfcXVldWVzLnBkZg==">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms<i class="fa fa-external-link-alt"></i></span>，Java 中 <code>ConcurrentLinkedQueue</code> 也是基于该论文的算法实现。</p><span id="more"></span><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>论文中 lock-free queue 算法的伪代码：</p><p>正如论文的题目描述的，它非常简单，代码量很少。主要思路就是使用 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJTk0JUU4JUJFJTgzJUU1JUI5JUI2JUU0JUJBJUE0JUU2JThEJUEy">CAS<i class="fa fa-external-link-alt"></i></span> 操作队列的头指针和尾指针，以实现线程安全。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">structure pointer_t &#123;ptr: pointer to node_t, count: unsigned integer&#125;</span><br><span class="line">structure node_t &#123;value: data type, next: pointer_t&#125;</span><br><span class="line">structure queue_t &#123;Head: pointer_t, Tail: pointer_t&#125;</span><br><span class="line"></span><br><span class="line">initialize(Q: pointer to queue_t)</span><br><span class="line">   node = new_node()        // Allocate a free node</span><br><span class="line">   node-&gt;next.ptr = NULL    // Make it the only node in the linked list</span><br><span class="line">   Q-&gt;Head.ptr = Q-&gt;Tail.ptr = node    // Both Head and Tail point to it</span><br><span class="line"></span><br><span class="line">enqueue(Q: pointer to queue_t, value: data type)</span><br><span class="line"> E1:   node = new_node()    // Allocate a new node from the free list</span><br><span class="line"> E2:   node-&gt;value = value    // Copy enqueued value into node</span><br><span class="line"> E3:   node-&gt;next.ptr = NULL    // Set next pointer of node to NULL</span><br><span class="line"> E4:   loop            // Keep trying until Enqueue is done</span><br><span class="line"> E5:      tail = Q-&gt;Tail    // Read Tail.ptr and Tail.count together</span><br><span class="line"> E6:      next = tail.ptr-&gt;next    // Read next ptr and count fields together</span><br><span class="line"> E7:      if tail == Q-&gt;Tail    // Are tail and next consistent?</span><br><span class="line">             // Was Tail pointing to the last node?</span><br><span class="line"> E8:         if next.ptr == NULL</span><br><span class="line">                // Try to link node at the end of the linked list</span><br><span class="line"> E9:            if CAS(&amp;tail.ptr-&gt;next, next, &lt;node, next.count+1&gt;)</span><br><span class="line">E10:               break    // Enqueue is done.  Exit loop</span><br><span class="line">E11:            endif</span><br><span class="line">E12:         else        // Tail was not pointing to the last node</span><br><span class="line">                // Try to swing Tail to the next node</span><br><span class="line">E13:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class="line">E14:         endif</span><br><span class="line">E15:      endif</span><br><span class="line">E16:   endloop</span><br><span class="line">       // Enqueue is done.  Try to swing Tail to the inserted node</span><br><span class="line">E17:   CAS(&amp;Q-&gt;Tail, tail, &lt;node, tail.count+1&gt;)</span><br><span class="line"></span><br><span class="line">dequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean</span><br><span class="line"> D1:   loop                 // Keep trying until Dequeue is done</span><br><span class="line"> D2:      head = Q-&gt;Head         // Read Head</span><br><span class="line"> D3:      tail = Q-&gt;Tail         // Read Tail</span><br><span class="line"> D4:      next = head.ptr-&gt;next    // Read Head.ptr-&gt;next</span><br><span class="line"> D5:      if head == Q-&gt;Head         // Are head, tail, and next consistent?</span><br><span class="line"> D6:         if head.ptr == tail.ptr // Is queue empty or Tail falling behind?</span><br><span class="line"> D7:            if next.ptr == NULL  // Is queue empty?</span><br><span class="line"> D8:               return FALSE      // Queue is empty, couldn&#x27;t dequeue</span><br><span class="line"> D9:            endif</span><br><span class="line">                // Tail is falling behind.  Try to advance it</span><br><span class="line">D10:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class="line">D11:         else             // No need to deal with Tail</span><br><span class="line">                // Read value before CAS</span><br><span class="line">                // Otherwise, another dequeue might free the next node</span><br><span class="line">D12:            *pvalue = next.ptr-&gt;value</span><br><span class="line">                // Try to swing Head to the next node</span><br><span class="line">D13:            if CAS(&amp;Q-&gt;Head, head, &lt;next.ptr, head.count+1&gt;)</span><br><span class="line">D14:               break             // Dequeue is done.  Exit loop</span><br><span class="line">D15:            endif</span><br><span class="line">D16:         endif</span><br><span class="line">D17:      endif</span><br><span class="line">D18:   endloop</span><br><span class="line">D19:   free(head.ptr)             // It is safe now to free the old node</span><br><span class="line">D20:   return TRUE                   // Queue was not empty, dequeue succeeded</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>简单起见，不考虑 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQUJBX3Byb2JsZW0=">ABA<i class="fa fa-external-link-alt"></i></span> 问题，所以没有实现带版本号的 CAS</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lockFreeQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    head unsafe.Pointer</span><br><span class="line">    tail unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>  <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    next  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockFreeQueue</span><span class="params">()</span></span> *lockFreeQueue &#123;</span><br><span class="line">    n := unsafe.Pointer(&amp;node&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> &amp;lockFreeQueue&#123;head: n, tail: n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockFreeQueue)</span></span> Enqueue(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    n := &amp;node&#123;value: v&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        tail := load(&amp;q.tail)</span><br><span class="line">        next := load(&amp;tail.next)</span><br><span class="line">        <span class="keyword">if</span> tail == load(&amp;q.tail) &#123;</span><br><span class="line">            <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cas(&amp;tail.next, next, n) &#123;</span><br><span class="line">                    cas(&amp;q.tail, tail, n)</span><br><span class="line">                    atomic.AddInt32(&amp;q.<span class="built_in">len</span>, <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cas(&amp;q.tail, tail, next)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockFreeQueue)</span></span> Dequeue() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        head := load(&amp;q.head)</span><br><span class="line">        tail := load(&amp;q.tail)</span><br><span class="line">        next := load(&amp;head.next)</span><br><span class="line">        <span class="keyword">if</span> head == load(&amp;q.head) &#123;</span><br><span class="line">            <span class="keyword">if</span> head == tail &#123;</span><br><span class="line">                <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                cas(&amp;q.tail, tail, next)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v := next.value</span><br><span class="line">                <span class="keyword">if</span> cas(&amp;q.head, head, next) &#123;</span><br><span class="line">                    atomic.AddInt32(&amp;q.<span class="built_in">len</span>, <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> v</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockFreeQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.LoadInt32(&amp;q.<span class="built_in">len</span>) != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(p *unsafe.Pointer)</span></span> *node &#123;</span><br><span class="line">    <span class="keyword">return</span> (*node)(atomic.LoadPointer(p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(p *unsafe.Pointer, old, <span class="built_in">new</span> *node)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(p,</span><br><span class="line">        unsafe.Pointer(old), unsafe.Pointer(<span class="built_in">new</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS91L3Njb3R0L3BhcGVycy8xOTk2X1BPRENfcXVldWVzLnBkZg==&quot;&gt;Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，Java 中 &lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt; 也是基于该论文的算法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blog.zcchub.xyz/categories/Golang/"/>
    
    
    <category term="并发" scheme="https://blog.zcchub.xyz/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="CAS" scheme="https://blog.zcchub.xyz/tags/CAS/"/>
    
    <category term="unsafe" scheme="https://blog.zcchub.xyz/tags/unsafe/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发】volatile 关键字基本理解与使用</title>
    <link href="https://blog.zcchub.xyz/java/volatile/"/>
    <id>https://blog.zcchub.xyz/java/volatile/</id>
    <published>2020-11-24T08:15:22.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile-的三个特性"><a href="#volatile-的三个特性" class="headerlink" title="volatile 的三个特性"></a>volatile 的三个特性</h2><ul><li>保证可见性</li><li><strong>不保证原子性</strong></li><li>禁止指令重排</li></ul><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h3 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h3><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><span id="more"></span><p>可能发生重排的代码：（意思就是第二行代码可能会先执行，听起来是不是有点匪夷所思）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>一定不会重排的代码（因为第 2 行依赖第 1 行的结果）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line">b += a;</span><br></pre></td></tr></table></figure><h3 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h3><p>观察下面这段代码的运行结果，假设没有重排，那么运行结果只有可能是以下 3 种：</p><ul><li>x &#x3D; 1, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>b = 1</code> 再执行 <code>x = b</code> 和 <code>y = a</code>）</li><li>x &#x3D; 0, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>x = b</code> 再执行 <code>b = 1</code> 和 <code>y = a</code>）</li><li>x &#x3D; 1, y &#x3D; 0（先执行了 <code>b = 1</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>x = b</code>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            x = y = a = b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概在运行几万次后会出现指令重排的现象，先执行了 <code>x = b</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>b = 1</code>。结果就是 x 和 y 都等于 0。</p><p><strong>解决办法</strong>：给四个变量加上 <code>volatile</code> 关键字，就不会出现预期之外的重排了。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>首先看一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果应该是符合我们预期的，由于主线程修改 <code>flag = false</code> ，所以终止了另一个线程中的死循环。</p><p>但是如果在 <code>flag = false</code> 前，让主线程睡一会：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现程序无法停止（依然处于死循环），这就体现了可见性的问题。每一个线程都会从<strong>主存</strong>中拷贝一份 <code>flag</code> 的副本到自己的<strong>工作内存</strong>，主线程中修改 <code>flag</code> 相当于修改了副本的值，然后再把副本的值刷到主存中。但是这个时候另一个线程并不知道主存中发生了什么变动， <code>while (flag)</code> 使用的依然是之前旧的副本，所以就导致了死循环，程序无法退出。（第一个例子是因为主线程跑得太快，在另一个线程开始从主存拷贝 <code>flag</code> 之前就已经把 <code>flag = false</code> 刷到主存里了）</p><p>加上 <code>volatile</code> 关键字后：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序成功退出。原因是主线程把 <code>flag</code> 刷到主存的同时会使其他线程的 <code>flag</code> 副本失效，下一次再判断 <code>while (flag)</code> 的时候就会重新从主存读取。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;volatile-的三个特性&quot;&gt;&lt;a href=&quot;#volatile-的三个特性&quot; class=&quot;headerlink&quot; title=&quot;volatile 的三个特性&quot;&gt;&lt;/a&gt;volatile 的三个特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;保证可见性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不保证原子性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;禁止指令重排&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;指令重排&quot;&gt;&lt;a href=&quot;#指令重排&quot; class=&quot;headerlink&quot; title=&quot;指令重排&quot;&gt;&lt;/a&gt;指令重排&lt;/h2&gt;&lt;h3 id=&quot;什么是指令重排&quot;&gt;&lt;a href=&quot;#什么是指令重排&quot; class=&quot;headerlink&quot; title=&quot;什么是指令重排&quot;&gt;&lt;/a&gt;什么是指令重排&lt;/h3&gt;&lt;p&gt;处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.zcchub.xyz/categories/Java/"/>
    
    
    <category term="并发" scheme="https://blog.zcchub.xyz/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发】重入锁（ReentrantLock）</title>
    <link href="https://blog.zcchub.xyz/java/reentrant-lock/"/>
    <id>https://blog.zcchub.xyz/java/reentrant-lock/</id>
    <published>2020-11-24T08:13:45.000Z</published>
    <updated>2022-04-02T14:48:25.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是“重入”"><a href="#什么是“重入”" class="headerlink" title="什么是“重入”"></a>什么是“重入”</h2><p>Re-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复<strong>仅仅局限于一个线程</strong>，观察下面的代码， <code>f1</code> 锁住 <code>lock</code> 之后， <code>f2</code> 依然能继续获取到 <code>lock</code> 并执行，因为它们都属于主线程。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                f2();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重入锁-VS-synchronized"><a href="#重入锁-VS-synchronized" class="headerlink" title="重入锁 VS synchronized"></a>重入锁 VS synchronized</h2><p>重入锁可以完全替代 <code>synchronized</code> 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 <code>synchronized</code> ，但从 JDK 6.0 开始，JDK 在 <code>synchronized</code> 上做了大量的优化，使得两者的性能差距并不大。</p><p>用两种方法分别实现 <code>num++</code>：</p><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ts[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">            ts[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ts[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ts[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">            ts[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ts[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h2><p>对于 <code>synchronized</code> 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。</p><p>模拟一个死锁的场景：两个线程都需要获取 <code>lock1</code>, <code>lock2</code> 两把锁，线程 <code>t1</code> 先获取了 <code>lock1</code> ，线程 <code>t2</code> 先获取了 <code>lock2</code> ，然后它们就开始无限等待对方让出锁。但是这个时候，如果中断了线程 <code>t2</code> ，并且释放 <code>t2</code> 占有的锁， <code>t1</code> 就能正常运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> lock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntLock</span><span class="params">(<span class="type">int</span> lock)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">                    lock1.lockInterruptibly();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        lock2.lockInterruptibly();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;t1成功获取两把锁&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t1被中断&quot;</span>);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock1.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lock2.lockInterruptibly();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        lock1.lockInterruptibly();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;t2成功获取两把锁&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2被中断&quot;</span>);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">IntLock</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntLock</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">IntLock</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntLock</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h2><p><code>tryLock()</code> 方法接收两个参数，一个表示等待时长，另外一个表示计时单位。也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 <code>true</code> 。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock success&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock failed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄得围在售票窗口前，售票员忙得焦头烂额，也顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure><p>当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个<strong>有序队列</strong>，因此公平锁的实现成本比较高，性能相对也非常低下，因此，<strong>默认情况下，锁是非公平的</strong>。如果没有特别的需求，也不需要使用公平锁。公平锁和非公平锁在线程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                fairLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，大部分情况下，两个线程是交替运行的。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">...</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是换成非公平锁之后，会发现连续多次都是同一个线程获取锁。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">Thread-0 获得锁</span><br><span class="line">...</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">Thread-1 获得锁</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是“重入”&quot;&gt;&lt;a href=&quot;#什么是“重入”&quot; class=&quot;headerlink&quot; title=&quot;什么是“重入”&quot;&gt;&lt;/a&gt;什么是“重入”&lt;/h2&gt;&lt;p&gt;Re-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复&lt;strong&gt;仅仅局限于一个线程&lt;/strong&gt;，观察下面的代码， &lt;code&gt;f1&lt;/code&gt; 锁住 &lt;code&gt;lock&lt;/code&gt; 之后， &lt;code&gt;f2&lt;/code&gt; 依然能继续获取到 &lt;code&gt;lock&lt;/code&gt; 并执行，因为它们都属于主线程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.zcchub.xyz/categories/Java/"/>
    
    
    <category term="并发" scheme="https://blog.zcchub.xyz/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
