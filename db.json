{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"e5e8f735cd45276aa843a1a32ca14484262ee06e","modified":1648888464959},{"_id":"source/images/apple-touch-icon.png","hash":"b528fe5189acc13818665046c70102cb9770e394","modified":1648888464963},{"_id":"source/categories/index.md","hash":"2dbcd757e5fc246e0d3e606003b83a9f2589a57c","modified":1648888464959},{"_id":"source/images/favicon-16x16.png","hash":"954745c11fa3c4e7bc58e91d425c1ccc6eda7c15","modified":1648888464963},{"_id":"source/images/favicon-32x32.png","hash":"1b8f0e67f7e2dddad737e6fdd518712171f24b62","modified":1648888464963},{"_id":"source/images/logo.svg","hash":"a28270f0854877d08528f82c8f2dfa25528787df","modified":1648888464963},{"_id":"source/tags/index.md","hash":"a6a07a958626e2d71ff9c334754456d878cdc772","modified":1648888464963},{"_id":"source/_posts/golang/bytebufferpool.md","hash":"72743aff3055eb118267fad32cb6753afd3dabef","modified":1648888464959},{"_id":"source/_posts/cloud/overlayfs.md","hash":"3ed0ce235f9051190c90f6c1abe840e72cab6136","modified":1648888464959},{"_id":"source/_posts/golang/gobreaker.md","hash":"eabc89024bc18983e85da2f91c81af561ff8365a","modified":1648888464959},{"_id":"source/_posts/golang/lock-free-queue.md","hash":"97f6d56ae0091f20620b45a1a707a6d41064c4c1","modified":1648888464959},{"_id":"source/_posts/java/reentrant-lock.md","hash":"925dbbe7914ccdb0078875c23cb005f070bd5f61","modified":1648888464959},{"_id":"source/_posts/github/first-pr.md","hash":"f8b963666f8aa1017fcab7fa24f105965be8fda5","modified":1648888464959},{"_id":"source/_posts/java/volatile.md","hash":"86c0423fcb8aca62f10d8d6a4dd04f004ea4eb4a","modified":1648888464959},{"_id":"source/_posts/journal/2021-12-26.md","hash":"4d30ae6fe11bb033eb3dafdb2f2288f7d5278efa","modified":1648888464959},{"_id":"source/_posts/tool/vagrant.md","hash":"999351a6a61662957671c2dfef84303351119da7","modified":1648888464959},{"_id":"source/_posts/vps/selfhosted.md","hash":"9ac4ea372e48bc52810d185afc59dcdc6a6e1f5a","modified":1648888464959},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"cf97b8bcd78e6f8b6d22e470528ad2c27156c95d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/package.json","hash":"afe8ce9cf1ed066534459be01c767792d79433aa","modified":1648889691273},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/README.md","hash":"c8fab0d6caf50be68662a4f9b86b87bde3ae354b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"7ac5700b08830381131a212c8cda65d73375b438","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"b5e2a35eb6fff56b6e32ce479e63b6fc5e44d5cb","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"3abdcb715562414063e0fb3eeb6244ce59c477e0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"72d4464cf01f8f34e524f26a1e9b1d063504e92d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"3d09c345d2e2ae2ab0fca10ff39b3b543b152c09","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"7d39204791687179576e22891a1a31766a089171","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"0d94ac5daa95f99046d66160d9f0f34ee786736c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"9a836d2bcc3defe4bd1ee51f5f4eb7006ebdd41b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":499162500000}],"Category":[{"name":"云计算","_id":"cl1hmczdl0004xeoa3bp983q8"},{"name":"Golang","_id":"cl1hmczdt000axeoa9xdjb32p"},{"name":"GitHub","_id":"cl1hmcze4000nxeoa47h8b0uv"},{"name":"Java","_id":"cl1hmcze5000sxeoaay8gbuzv"},{"name":"日记","_id":"cl1hmcze80012xeoa3pef9o8k"},{"name":"开发工具","_id":"cl1hmcze90016xeoa1ivk4bbb"},{"name":"VPS","_id":"cl1hmczea0019xeoa491w9yei"}],"Data":[],"Page":[{"title":"分类","date":"2021-10-06T06:08:45.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-10-06 14:08:45\ntype: categories\ncomments: false\n---\n","updated":"2022-04-02T08:34:24.959Z","path":"categories/index.html","layout":"page","_id":"cl1hmczd40000xeoagrnm6f4q","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"关于","date":"2021-10-06T06:09:34.000Z","_content":"\n还没想好自我介绍\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-10-06 14:09:34\n---\n\n还没想好自我介绍\n","updated":"2022-04-02T08:34:24.959Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl1hmczdg0002xeoaemiw93f4","content":"<p>还没想好自我介绍</p>\n","site":{"data":{}},"length":8,"excerpt":"","more":"<p>还没想好自我介绍</p>\n"},{"title":"标签","date":"2021-10-06T06:08:10.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-10-06 14:08:10\ntype: tags\ncomments: false\n---\n","updated":"2022-04-02T08:34:24.963Z","path":"tags/index.html","layout":"page","_id":"cl1hmczdp0006xeoacy3rba4t","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"堆叠文件系统 OverlayFS","date":"2021-10-24T05:12:42.000Z","_content":"\n因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。\n\n<!-- more -->\n\n## 参考资料\n\n- [深入理解 overlayfs](https://blog.csdn.net/qq_15770331/article/details/96699386)\n- [Linux Kernel documentation](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html)\n\n## 环境准备\n\n- VirtualBox\n- Vagrant\n\n用 vagrant 跑一个带有 docker 的虚拟机：\n\n```rb Vagrantfile\n# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n$script = <<-'SCRIPT'\nsudo tee /etc/apt/sources.list <<-'EOF'\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\nEOF\nsudo apt-get -y update\n\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\nsudo apt-get -y update\nsudo apt-get -y install docker-ce\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo systemctl enable docker\n# Make sure we can actually use docker as the vagrant user\nsudo usermod -aG docker vagrant\nsudo docker --version\n\nsudo apt-get -y install bash-completion tree\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\n  config.vm.synced_folder \".\", \"/vagrant\", disabled: true\n\n  config.vm.provision \"shell\", inline: $script, privileged: false\nend\n```\n\n## 初步认识\n\n随便拉一个镜像：\n\n```text\nvagrant@vagrant:~$ docker pull alpine\nUsing default tag: latest\nlatest: Pulling from library/alpine\na0d0a0d46f8b: Pull complete\nDigest: sha256:e1c082e3d3c45cccac829840a25941e679c25d438cc8412c2fa221cf1a824e6a\nStatus: Downloaded newer image for alpine:latest\ndocker.io/library/alpine:latest\n```\n\n这时，我们就能在磁盘上找到对应的目录结构：\n\n```text\nvagrant@vagrant:~$ sudo su\n\nroot@vagrant:/home/vagrant# cd /var/lib/docker/overlay2/\n\nroot@vagrant:/var/lib/docker/overlay2# ls\nae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc  l\n\nroot@vagrant:/var/lib/docker/overlay2# ls ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc/diff/\nbin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n```\n\n再开一个窗口，启动一个容器：\n\n```text\nvagrant@vagrant:~$ docker run --rm -it alpine sh\n/ # ls\nbin    etc    lib    mnt    proc   run    srv    tmp    var\ndev    home   media  opt    root   sbin   sys    usr\n```\n\n宿主机上的 overlay2 目录多出了一些东西：\n\n```text\nroot@vagrant:/var/lib/docker/overlay2# ls\n7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6       ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc\n7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6-init  l\n\nroot@vagrant:/var/lib/docker/overlay2# mount | grep overlay\noverlay on /var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6ND2PL2RECUKJ3KFZYGPYCA564:/var/lib/docker/overlay2/l/FDPTXFIRIH3NAJ6N5KIKDUMC6O,upperdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/diff,workdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/work)\n\nroot@vagrant:/var/lib/docker/overlay2# ls 7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged/\nbin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n```\n\n一个名为 `overlay` 的驱动挂载到了 `/var/lib/docker/overlay2/7fca3.../merged`，从挂载信息可以看出 merged 目录是由多个目录联合挂载而成，lowerdir 为只读层 (ro)，upperdir 为可读可写层 (rw)，当需要修改 lowerdir 中的文件时，fs 会采用**写时复制**的策略，将文件从 lowerdir 复制到 upperdir 进行修改。在 merged 目录中（或者说在 docker 容器中）是感知不到这些复杂逻辑的，和操作正常目录没有区别\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161306717.jpeg)\n\n## 实践\n\n大概了解了 OverlayFS 之后，我们抛开 Docker 仅仅用 Linux 命令行就能模拟出一个简单的容器（注意只是简单模拟，几乎谈不上什么隔离性）\n\n在开始前可以切换到 root，免得不必要的麻烦\n\n```bash\nsudo su\n```\n\n### 制作基础 rootfs\n\n最后利用一下 Docker，导出一个 alpine 的 rootfs：\n\n```bash\nmkdir rootfs && docker export $(docker create alpine) | tar -C rootfs -xvf -\n```\n\n### Lowerdirs\n\n由于 lowerdir 可以配置多个，所以，我们可以利用这一特性对 rootfs 进行一些定制。\n\n替换中科大源：\n\n```bash\nmkdir -p rootfs-init/etc/apk\ncp rootfs/etc/apk/repositories rootfs-init/etc/apk/\nsed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' rootfs-init/etc/apk/repositories\n```\n\n配置 DNS：\n\n```bash\necho 'nameserver 223.5.5.5' > rootfs-init/etc/resolv.conf\n```\n\n### 准备其他目录\n\n创建 upperdir，workdir 和 merged\n\n```bash\nmkdir diff work merged\n```\n\n最终的目录结构：\n\n```text\nroot@vagrant:~# tree -L 2\n.\n├── diff\n├── merged\n├── rootfs\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs-init\n│   └── etc\n└── work\n\n23 directories, 0 files\n```\n\n### 手动挂载\n\n将准备好的目录挂在到 merged:\n\n```bash\nmount overlay -t overlay -o lowerdir=/root/rootfs-init:/root/rootfs,upperdir=/root/diff,workdir=/root/work /root/merged\n```\n\n### 使用容器\n\n利用 chroot 改变根文件系统\n\n```bash\ncd merged\nchroot $PWD apk update\nchroot $PWD apk upgrade\nchroot $PWD apk add gcc\nchroot $PWD gcc -v\nchroot $PWD apk add neofetch\nchroot $PWD neofetch\n```\n\n至此，我们已经通过 OverlayFS 和 chroot 实现了一个简易的容器\n\n```text\nroot@vagrant:~# tree -L 2\n.\n├── diff\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── lib\n│   ├── root\n│   ├── usr\n│   └── var\n├── merged\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs-init\n│   └── etc\n└── work\n    └── work\n\n48 directories, 0 files\n```\n","source":"_posts/cloud/overlayfs.md","raw":"---\ntitle: 堆叠文件系统 OverlayFS\ndate: 2021-10-24 13:12:42\ncategories: 云计算\ntags:\n  - Linux\n  - Docker\n  - OverlayFS\n  - chroot\n---\n\n因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。\n\n<!-- more -->\n\n## 参考资料\n\n- [深入理解 overlayfs](https://blog.csdn.net/qq_15770331/article/details/96699386)\n- [Linux Kernel documentation](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html)\n\n## 环境准备\n\n- VirtualBox\n- Vagrant\n\n用 vagrant 跑一个带有 docker 的虚拟机：\n\n```rb Vagrantfile\n# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n$script = <<-'SCRIPT'\nsudo tee /etc/apt/sources.list <<-'EOF'\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\nEOF\nsudo apt-get -y update\n\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\nsudo apt-get -y update\nsudo apt-get -y install docker-ce\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo systemctl enable docker\n# Make sure we can actually use docker as the vagrant user\nsudo usermod -aG docker vagrant\nsudo docker --version\n\nsudo apt-get -y install bash-completion tree\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\n  config.vm.synced_folder \".\", \"/vagrant\", disabled: true\n\n  config.vm.provision \"shell\", inline: $script, privileged: false\nend\n```\n\n## 初步认识\n\n随便拉一个镜像：\n\n```text\nvagrant@vagrant:~$ docker pull alpine\nUsing default tag: latest\nlatest: Pulling from library/alpine\na0d0a0d46f8b: Pull complete\nDigest: sha256:e1c082e3d3c45cccac829840a25941e679c25d438cc8412c2fa221cf1a824e6a\nStatus: Downloaded newer image for alpine:latest\ndocker.io/library/alpine:latest\n```\n\n这时，我们就能在磁盘上找到对应的目录结构：\n\n```text\nvagrant@vagrant:~$ sudo su\n\nroot@vagrant:/home/vagrant# cd /var/lib/docker/overlay2/\n\nroot@vagrant:/var/lib/docker/overlay2# ls\nae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc  l\n\nroot@vagrant:/var/lib/docker/overlay2# ls ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc/diff/\nbin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n```\n\n再开一个窗口，启动一个容器：\n\n```text\nvagrant@vagrant:~$ docker run --rm -it alpine sh\n/ # ls\nbin    etc    lib    mnt    proc   run    srv    tmp    var\ndev    home   media  opt    root   sbin   sys    usr\n```\n\n宿主机上的 overlay2 目录多出了一些东西：\n\n```text\nroot@vagrant:/var/lib/docker/overlay2# ls\n7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6       ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc\n7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6-init  l\n\nroot@vagrant:/var/lib/docker/overlay2# mount | grep overlay\noverlay on /var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6ND2PL2RECUKJ3KFZYGPYCA564:/var/lib/docker/overlay2/l/FDPTXFIRIH3NAJ6N5KIKDUMC6O,upperdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/diff,workdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/work)\n\nroot@vagrant:/var/lib/docker/overlay2# ls 7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged/\nbin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n```\n\n一个名为 `overlay` 的驱动挂载到了 `/var/lib/docker/overlay2/7fca3.../merged`，从挂载信息可以看出 merged 目录是由多个目录联合挂载而成，lowerdir 为只读层 (ro)，upperdir 为可读可写层 (rw)，当需要修改 lowerdir 中的文件时，fs 会采用**写时复制**的策略，将文件从 lowerdir 复制到 upperdir 进行修改。在 merged 目录中（或者说在 docker 容器中）是感知不到这些复杂逻辑的，和操作正常目录没有区别\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161306717.jpeg)\n\n## 实践\n\n大概了解了 OverlayFS 之后，我们抛开 Docker 仅仅用 Linux 命令行就能模拟出一个简单的容器（注意只是简单模拟，几乎谈不上什么隔离性）\n\n在开始前可以切换到 root，免得不必要的麻烦\n\n```bash\nsudo su\n```\n\n### 制作基础 rootfs\n\n最后利用一下 Docker，导出一个 alpine 的 rootfs：\n\n```bash\nmkdir rootfs && docker export $(docker create alpine) | tar -C rootfs -xvf -\n```\n\n### Lowerdirs\n\n由于 lowerdir 可以配置多个，所以，我们可以利用这一特性对 rootfs 进行一些定制。\n\n替换中科大源：\n\n```bash\nmkdir -p rootfs-init/etc/apk\ncp rootfs/etc/apk/repositories rootfs-init/etc/apk/\nsed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' rootfs-init/etc/apk/repositories\n```\n\n配置 DNS：\n\n```bash\necho 'nameserver 223.5.5.5' > rootfs-init/etc/resolv.conf\n```\n\n### 准备其他目录\n\n创建 upperdir，workdir 和 merged\n\n```bash\nmkdir diff work merged\n```\n\n最终的目录结构：\n\n```text\nroot@vagrant:~# tree -L 2\n.\n├── diff\n├── merged\n├── rootfs\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs-init\n│   └── etc\n└── work\n\n23 directories, 0 files\n```\n\n### 手动挂载\n\n将准备好的目录挂在到 merged:\n\n```bash\nmount overlay -t overlay -o lowerdir=/root/rootfs-init:/root/rootfs,upperdir=/root/diff,workdir=/root/work /root/merged\n```\n\n### 使用容器\n\n利用 chroot 改变根文件系统\n\n```bash\ncd merged\nchroot $PWD apk update\nchroot $PWD apk upgrade\nchroot $PWD apk add gcc\nchroot $PWD gcc -v\nchroot $PWD apk add neofetch\nchroot $PWD neofetch\n```\n\n至此，我们已经通过 OverlayFS 和 chroot 实现了一个简易的容器\n\n```text\nroot@vagrant:~# tree -L 2\n.\n├── diff\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── lib\n│   ├── root\n│   ├── usr\n│   └── var\n├── merged\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs\n│   ├── bin\n│   ├── dev\n│   ├── etc\n│   ├── home\n│   ├── lib\n│   ├── media\n│   ├── mnt\n│   ├── opt\n│   ├── proc\n│   ├── root\n│   ├── run\n│   ├── sbin\n│   ├── srv\n│   ├── sys\n│   ├── tmp\n│   ├── usr\n│   └── var\n├── rootfs-init\n│   └── etc\n└── work\n    └── work\n\n48 directories, 0 files\n```\n","slug":"cloud/overlayfs","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdc0001xeoa0czehi1r","content":"<p>因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NzcwMzMxL2FydGljbGUvZGV0YWlscy85NjY5OTM4Ng==\">深入理解 overlayfs<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvb3ZlcmxheWZzLmh0bWw=\">Linux Kernel documentation<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>VirtualBox</li>\n<li>Vagrant</li>\n</ul>\n<p>用 vagrant 跑一个带有 docker 的虚拟机：</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- mode: ruby -*-</span></span><br><span class=\"line\"><span class=\"comment\"># vi: set ft=ruby :</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$script</span> = <span class=\"string\">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class=\"line\"><span class=\"string\">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class=\"line\"><span class=\"string\">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install docker-ce</span></span><br><span class=\"line\"><span class=\"string\">sudo mkdir -p /etc/docker</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl daemon-reload</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl restart docker</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl enable docker</span></span><br><span class=\"line\"><span class=\"string\"># Make sure we can actually use docker as the vagrant user</span></span><br><span class=\"line\"><span class=\"string\">sudo usermod -aG docker vagrant</span></span><br><span class=\"line\"><span class=\"string\">sudo docker --version</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install bash-completion tree</span></span><br><span class=\"line\"><span class=\"string\">SCRIPT</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\">  config.vm.synced_folder <span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;/vagrant&quot;</span>, <span class=\"symbol\">disabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision <span class=\"string\">&quot;shell&quot;</span>, <span class=\"symbol\">inline:</span> <span class=\"variable\">$script</span>, <span class=\"symbol\">privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初步认识\"><a href=\"#初步认识\" class=\"headerlink\" title=\"初步认识\"></a>初步认识</h2><p>随便拉一个镜像：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ docker pull alpine</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/alpine</span><br><span class=\"line\">a0d0a0d46f8b: Pull complete</span><br><span class=\"line\">Digest: sha256:e1c082e3d3c45cccac829840a25941e679c25d438cc8412c2fa221cf1a824e6a</span><br><span class=\"line\">Status: Downloaded newer image for alpine:latest</span><br><span class=\"line\">docker.io/library/alpine:latest</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们就能在磁盘上找到对应的目录结构：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ sudo su</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/home/vagrant# cd /var/lib/docker/overlay2/</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class=\"line\">ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc  l</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc/diff/</span><br><span class=\"line\">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>\n\n<p>再开一个窗口，启动一个容器：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ docker run --rm -it alpine sh</span><br><span class=\"line\">/ # ls</span><br><span class=\"line\">bin    etc    lib    mnt    proc   run    srv    tmp    var</span><br><span class=\"line\">dev    home   media  opt    root   sbin   sys    usr</span><br></pre></td></tr></table></figure>\n\n<p>宿主机上的 overlay2 目录多出了一些东西：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class=\"line\">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6       ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc</span><br><span class=\"line\">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6-init  l</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# mount | grep overlay</span><br><span class=\"line\">overlay on /var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6ND2PL2RECUKJ3KFZYGPYCA564:/var/lib/docker/overlay2/l/FDPTXFIRIH3NAJ6N5KIKDUMC6O,upperdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/diff,workdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/work)</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls 7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged/</span><br><span class=\"line\">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>\n\n<p>一个名为 <code>overlay</code> 的驱动挂载到了 <code>/var/lib/docker/overlay2/7fca3.../merged</code>，从挂载信息可以看出 merged 目录是由多个目录联合挂载而成，lowerdir 为只读层 (ro)，upperdir 为可读可写层 (rw)，当需要修改 lowerdir 中的文件时，fs 会采用<strong>写时复制</strong>的策略，将文件从 lowerdir 复制到 upperdir 进行修改。在 merged 目录中（或者说在 docker 容器中）是感知不到这些复杂逻辑的，和操作正常目录没有区别</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161306717.jpeg\" loading=\"lazy\"></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>大概了解了 OverlayFS 之后，我们抛开 Docker 仅仅用 Linux 命令行就能模拟出一个简单的容器（注意只是简单模拟，几乎谈不上什么隔离性）</p>\n<p>在开始前可以切换到 root，免得不必要的麻烦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo su</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作基础-rootfs\"><a href=\"#制作基础-rootfs\" class=\"headerlink\" title=\"制作基础 rootfs\"></a>制作基础 rootfs</h3><p>最后利用一下 Docker，导出一个 alpine 的 rootfs：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> rootfs &amp;&amp; docker <span class=\"built_in\">export</span> $(docker create alpine) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lowerdirs\"><a href=\"#Lowerdirs\" class=\"headerlink\" title=\"Lowerdirs\"></a>Lowerdirs</h3><p>由于 lowerdir 可以配置多个，所以，我们可以利用这一特性对 rootfs 进行一些定制。</p>\n<p>替换中科大源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p rootfs-init/etc/apk</span><br><span class=\"line\"><span class=\"built_in\">cp</span> rootfs/etc/apk/repositories rootfs-init/etc/apk/</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> rootfs-init/etc/apk/repositories</span><br></pre></td></tr></table></figure>\n\n<p>配置 DNS：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;nameserver 223.5.5.5&#x27;</span> &gt; rootfs-init/etc/resolv.conf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"准备其他目录\"><a href=\"#准备其他目录\" class=\"headerlink\" title=\"准备其他目录\"></a>准备其他目录</h3><p>创建 upperdir，workdir 和 merged</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> diff work merged</span><br></pre></td></tr></table></figure>\n\n<p>最终的目录结构：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:~# tree -L 2</span><br><span class=\"line\">.</span><br><span class=\"line\">├── diff</span><br><span class=\"line\">├── merged</span><br><span class=\"line\">├── rootfs</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs-init</span><br><span class=\"line\">│   └── etc</span><br><span class=\"line\">└── work</span><br><span class=\"line\"></span><br><span class=\"line\">23 directories, 0 files</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手动挂载\"><a href=\"#手动挂载\" class=\"headerlink\" title=\"手动挂载\"></a>手动挂载</h3><p>将准备好的目录挂在到 merged:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount overlay -t overlay -o lowerdir=/root/rootfs-init:/root/rootfs,upperdir=/root/diff,workdir=/root/work /root/merged</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用容器\"><a href=\"#使用容器\" class=\"headerlink\" title=\"使用容器\"></a>使用容器</h3><p>利用 chroot 改变根文件系统</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> merged</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk update</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk upgrade</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk add gcc</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> gcc -v</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk add neofetch</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> neofetch</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们已经通过 OverlayFS 和 chroot 实现了一个简易的容器</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:~# tree -L 2</span><br><span class=\"line\">.</span><br><span class=\"line\">├── diff</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── merged</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs-init</span><br><span class=\"line\">│   └── etc</span><br><span class=\"line\">└── work</span><br><span class=\"line\">    └── work</span><br><span class=\"line\"></span><br><span class=\"line\">48 directories, 0 files</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":5559,"excerpt":"<p>因为工作需求，所以花时间了解了一下 OverlayFS。第一次知道这个概念，是使用 Docker 时，它默认使用的 Graph Driver 是 Overlay2，容器的 rootfs 就是直接以目录的形式在宿主机上组织。</p>","more":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NzcwMzMxL2FydGljbGUvZGV0YWlscy85NjY5OTM4Ng==\">深入理解 overlayfs<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvb3ZlcmxheWZzLmh0bWw=\">Linux Kernel documentation<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>VirtualBox</li>\n<li>Vagrant</li>\n</ul>\n<p>用 vagrant 跑一个带有 docker 的虚拟机：</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- mode: ruby -*-</span></span><br><span class=\"line\"><span class=\"comment\"># vi: set ft=ruby :</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$script</span> = <span class=\"string\">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class=\"line\"><span class=\"string\">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class=\"line\"><span class=\"string\">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install docker-ce</span></span><br><span class=\"line\"><span class=\"string\">sudo mkdir -p /etc/docker</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl daemon-reload</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl restart docker</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl enable docker</span></span><br><span class=\"line\"><span class=\"string\"># Make sure we can actually use docker as the vagrant user</span></span><br><span class=\"line\"><span class=\"string\">sudo usermod -aG docker vagrant</span></span><br><span class=\"line\"><span class=\"string\">sudo docker --version</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install bash-completion tree</span></span><br><span class=\"line\"><span class=\"string\">SCRIPT</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\">  config.vm.synced_folder <span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;/vagrant&quot;</span>, <span class=\"symbol\">disabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision <span class=\"string\">&quot;shell&quot;</span>, <span class=\"symbol\">inline:</span> <span class=\"variable\">$script</span>, <span class=\"symbol\">privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初步认识\"><a href=\"#初步认识\" class=\"headerlink\" title=\"初步认识\"></a>初步认识</h2><p>随便拉一个镜像：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ docker pull alpine</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/alpine</span><br><span class=\"line\">a0d0a0d46f8b: Pull complete</span><br><span class=\"line\">Digest: sha256:e1c082e3d3c45cccac829840a25941e679c25d438cc8412c2fa221cf1a824e6a</span><br><span class=\"line\">Status: Downloaded newer image for alpine:latest</span><br><span class=\"line\">docker.io/library/alpine:latest</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们就能在磁盘上找到对应的目录结构：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ sudo su</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/home/vagrant# cd /var/lib/docker/overlay2/</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class=\"line\">ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc  l</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc/diff/</span><br><span class=\"line\">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>\n\n<p>再开一个窗口，启动一个容器：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant@vagrant:~$ docker run --rm -it alpine sh</span><br><span class=\"line\">/ # ls</span><br><span class=\"line\">bin    etc    lib    mnt    proc   run    srv    tmp    var</span><br><span class=\"line\">dev    home   media  opt    root   sbin   sys    usr</span><br></pre></td></tr></table></figure>\n\n<p>宿主机上的 overlay2 目录多出了一些东西：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls</span><br><span class=\"line\">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6       ae64cdecc41d55f445ce1bed819dd312459bc7f2a2ddc80df60c789a5e3b06dc</span><br><span class=\"line\">7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6-init  l</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# mount | grep overlay</span><br><span class=\"line\">overlay on /var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6ND2PL2RECUKJ3KFZYGPYCA564:/var/lib/docker/overlay2/l/FDPTXFIRIH3NAJ6N5KIKDUMC6O,upperdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/diff,workdir=/var/lib/docker/overlay2/7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/work)</span><br><span class=\"line\"></span><br><span class=\"line\">root@vagrant:/var/lib/docker/overlay2# ls 7fca31029adbb299211e702a704981f8dcf7a437d6522b565de0b11c353c78e6/merged/</span><br><span class=\"line\">bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>\n\n<p>一个名为 <code>overlay</code> 的驱动挂载到了 <code>/var/lib/docker/overlay2/7fca3.../merged</code>，从挂载信息可以看出 merged 目录是由多个目录联合挂载而成，lowerdir 为只读层 (ro)，upperdir 为可读可写层 (rw)，当需要修改 lowerdir 中的文件时，fs 会采用<strong>写时复制</strong>的策略，将文件从 lowerdir 复制到 upperdir 进行修改。在 merged 目录中（或者说在 docker 容器中）是感知不到这些复杂逻辑的，和操作正常目录没有区别</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161306717.jpeg\" loading=\"lazy\"></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>大概了解了 OverlayFS 之后，我们抛开 Docker 仅仅用 Linux 命令行就能模拟出一个简单的容器（注意只是简单模拟，几乎谈不上什么隔离性）</p>\n<p>在开始前可以切换到 root，免得不必要的麻烦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo su</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"制作基础-rootfs\"><a href=\"#制作基础-rootfs\" class=\"headerlink\" title=\"制作基础 rootfs\"></a>制作基础 rootfs</h3><p>最后利用一下 Docker，导出一个 alpine 的 rootfs：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> rootfs &amp;&amp; docker <span class=\"built_in\">export</span> $(docker create alpine) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lowerdirs\"><a href=\"#Lowerdirs\" class=\"headerlink\" title=\"Lowerdirs\"></a>Lowerdirs</h3><p>由于 lowerdir 可以配置多个，所以，我们可以利用这一特性对 rootfs 进行一些定制。</p>\n<p>替换中科大源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p rootfs-init/etc/apk</span><br><span class=\"line\"><span class=\"built_in\">cp</span> rootfs/etc/apk/repositories rootfs-init/etc/apk/</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> rootfs-init/etc/apk/repositories</span><br></pre></td></tr></table></figure>\n\n<p>配置 DNS：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;nameserver 223.5.5.5&#x27;</span> &gt; rootfs-init/etc/resolv.conf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"准备其他目录\"><a href=\"#准备其他目录\" class=\"headerlink\" title=\"准备其他目录\"></a>准备其他目录</h3><p>创建 upperdir，workdir 和 merged</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> diff work merged</span><br></pre></td></tr></table></figure>\n\n<p>最终的目录结构：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:~# tree -L 2</span><br><span class=\"line\">.</span><br><span class=\"line\">├── diff</span><br><span class=\"line\">├── merged</span><br><span class=\"line\">├── rootfs</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs-init</span><br><span class=\"line\">│   └── etc</span><br><span class=\"line\">└── work</span><br><span class=\"line\"></span><br><span class=\"line\">23 directories, 0 files</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手动挂载\"><a href=\"#手动挂载\" class=\"headerlink\" title=\"手动挂载\"></a>手动挂载</h3><p>将准备好的目录挂在到 merged:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount overlay -t overlay -o lowerdir=/root/rootfs-init:/root/rootfs,upperdir=/root/diff,workdir=/root/work /root/merged</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用容器\"><a href=\"#使用容器\" class=\"headerlink\" title=\"使用容器\"></a>使用容器</h3><p>利用 chroot 改变根文件系统</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> merged</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk update</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk upgrade</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk add gcc</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> gcc -v</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> apk add neofetch</span><br><span class=\"line\"><span class=\"built_in\">chroot</span> <span class=\"variable\">$PWD</span> neofetch</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们已经通过 OverlayFS 和 chroot 实现了一个简易的容器</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@vagrant:~# tree -L 2</span><br><span class=\"line\">.</span><br><span class=\"line\">├── diff</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── merged</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs</span><br><span class=\"line\">│   ├── bin</span><br><span class=\"line\">│   ├── dev</span><br><span class=\"line\">│   ├── etc</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── lib</span><br><span class=\"line\">│   ├── media</span><br><span class=\"line\">│   ├── mnt</span><br><span class=\"line\">│   ├── opt</span><br><span class=\"line\">│   ├── proc</span><br><span class=\"line\">│   ├── root</span><br><span class=\"line\">│   ├── run</span><br><span class=\"line\">│   ├── sbin</span><br><span class=\"line\">│   ├── srv</span><br><span class=\"line\">│   ├── sys</span><br><span class=\"line\">│   ├── tmp</span><br><span class=\"line\">│   ├── usr</span><br><span class=\"line\">│   └── var</span><br><span class=\"line\">├── rootfs-init</span><br><span class=\"line\">│   └── etc</span><br><span class=\"line\">└── work</span><br><span class=\"line\">    └── work</span><br><span class=\"line\"></span><br><span class=\"line\">48 directories, 0 files</span><br></pre></td></tr></table></figure>"},{"title":"高性能字节池 - bytebufferpool 源码分析","date":"2021-06-28T08:19:02.000Z","_content":"\n## 简介\n\n今天的主角是 [bytebufferpool](https://github.com/valyala/bytebufferpool) ，仓库的 README 文件是这么描述 bytebufferpool 的：\n\n> Currently bytebufferpool is fastest and most effective buffer pool written in Go.\n\n<!-- more -->\n\nbytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（[fasthttp](https://github.com/valyala/fasthttp), [quicktemplate](https://github.com/valyala/quicktemplate), [gnet](https://github.com/panjf2000/gnet)）\n\n什么是字节池？在读取文件或者从 `io.Reader` 获取数据时，一般都需要创建一个字节切片 `[]byte` 作为缓冲，如果对于这种方法有大量的调用，就会频繁地创建 `[]byte` ，这需要太多内存的申请和释放，增大了 GC 的压力。这个时候“池化”技术就派上了用场，通过复用对象以减少内存的分配和释放。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    r, _ := os.Open(\"./main.go\")\n    // 普通方式\n    buf := make([]byte, 64)\n    for {\n        n, err := r.Read(buf)\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            log.Fatal(err)\n        }\n        fmt.Print(string(buf[:n]))\n    }\n}\n```\n\n## 简单实现\n\n### MinIO BytePoolCap\n\nMinIO 中使用 `channel` 实现了一个非常简单的**有界**字节池 [bpool](https://github.com/minio/minio/blob/master/internal/bpool/bpool.go)\n\n```go\ntype BytePoolCap struct {\n    c    chan []byte\n    w    int\n    wcap int\n}\n\nfunc NewBytePoolCap(maxSize int, width int, capwidth int) (bp *BytePoolCap) {\n    return &BytePoolCap{\n        c:    make(chan []byte, maxSize),\n        w:    width,\n        wcap: capwidth,\n    }\n}\n```\n\n- `c` 用来存放字节切片（这也就是为什么**有界**的原因）\n- `w` 表示创建字节切片的 `len`\n- `wcap` 表示创建字节切片的 `cap`\n\n`Get()` 方法, 从池中获取字节切片：\n\n```go\nfunc (bp *BytePoolCap) Get() (b []byte) {\n    select {\n    case b = <-bp.c:\n        // channel 中存在 []byte 则复用\n    default:\n        // 否则创建 []byte\n        if bp.wcap > 0 {\n            b = make([]byte, bp.w, bp.wcap)\n        } else {\n            b = make([]byte, bp.w)\n        }\n    }\n    return\n}\n```\n\n`Put([]byte)` 方法，将使用完的切片放回池中，以被下一次获取：\n\n```go\nfunc (bp *BytePoolCap) Put(b []byte) {\n    select {\n    case bp.c <- b:\n        // channel 放得下\n    default:\n        // channel 放不下的话则不进行任何操作，直接丢弃这个 []byte\n    }\n}\n```\n\n使用示例\n\n```go\n// 多个 goroutine 公用一个 pool\nvar bp = bpool.NewBytePoolCap(100, 64, 64)\n\n// func ...\nbuf := bp.Get()\ndefer bp.Put(buf)\n\n// use buf ...\n```\n\n### sync.Pool\n\n谈到“池”，很容易想到 Go 标准库中的 `sync.Pool`，我们可以用几行代码就实现一个简单的字节池：\n\n```go\npool := &sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 64)\n    },\n}\n```\n\n然后就可以使用 `pool.Get().([]byte)` 从池中取字节切片，使用完后调用 `pool.Put(buf)` 归还到池中。\n\n## 问题分析\n\n上面的两种字节池实现都存在许多问题：池中新建的字节切片的 `len` 和 `cap` 都是创建池的时候固定的，不能动态修改。另外，如果往字节切片写入了大量数据（发生多次扩容），此时再将这样的字节切片放回池中，显然会造成内存浪费。\n\n所以需要解决的问题：\n\n1. 动态修改新分配字节切片的大小\n2. 阻止大切片放回字节池\n\n## ByteBufferPool\n\nByteBufferPool 中实现了一个类似 `bytes.Buffer` 的结构（[ByteBuffer](https://github.com/valyala/bytebufferpool/blob/master/bytebuffer.go)），它封装了一些对 `[]byte` 的复杂操作，从 benchmark 的结果可以看出它的性能比 `bytes.Buffer` 略高一些，但它不是字节池的重点，所以就不贴代码了。\n\nByteBufferPool 是怎么解决上述问题的？\n\n```go\nconst (\n    minBitSize = 6  // 2**6=64 is a CPU cache line size\n\n    // 将 buf 的大小划分为 20 个区间\n    // ==> (0, 64], (64, 128], (128, 256], ... , (8388608, 16777216], (16777216, 33554432]\n    // 超过 33554432 的也属于最后一个区间\n    steps = 20\n\n    minSize = 1 << minBitSize               // 64\n    maxSize = 1 << (minBitSize + steps - 1) // 33554432\n\n    calibrateCallsThreshold = 42000\n    maxPercentile           = 0.95\n)\n\ntype Pool struct {\n    calls       [steps]uint64 // 不同大小 buf 的使用频次\n    calibrating uint64        // 标记是否正在校准（校准过程就是调整 defaultSize 和 maxSize）\n\n    defaultSize uint64 // make []byte 时的 cap\n    maxSize     uint64 // 能放回池中的最大 buf 大小\n\n    pool sync.Pool // 存储 buf\n}\n\nfunc (p *Pool) Get() *ByteBuffer {\n    v := p.pool.Get()\n    // 如果池中有 buf 直接返回\n    if v != nil {\n        return v.(*ByteBuffer)\n    }\n    // 否则新建一个 cap 为 defaultSize 的 buf\n    return &ByteBuffer{\n        B: make([]byte, 0, atomic.LoadUint64(&p.defaultSize)),\n    }\n}\n```\n\n继续查看 `Put()`，从这就可以看出 ByteBufferPool 的主要逻辑了：\n\n```go\nfunc (p *Pool) Put(b *ByteBuffer) {\n    // len 所在 “区间” 的下标\n    idx := index(len(b.B))\n\n    // 解决了问题1：动态调整 size\n    // 使用频次加1，如果超过了阈值（42000）则进行校准\n    if atomic.AddUint64(&p.calls[idx], 1) > calibrateCallsThreshold {\n        p.calibrate()\n    }\n\n    // 解决了问题2：阻止大切片放回字节池\n    // 如果还未设置 maxSize 或 cap 小于等于 maxSize 才执行 Put\n    maxSize := int(atomic.LoadUint64(&p.maxSize))\n    if maxSize == 0 || cap(b.B) <= maxSize {\n        b.Reset()\n        p.pool.Put(b)\n    }\n}\n\nfunc index(n int) int {\n    n--\n    n >>= minBitSize\n    idx := 0\n    for n > 0 {\n        n >>= 1\n        idx++\n    }\n    if idx >= steps {\n        idx = steps - 1\n    }\n    return idx\n}\n```\n\n划分区间的目的就是方便统计出程序近一段时间内**最经常使用**多大的 buf，从而决定 `defaultSize` 和 `maxSize`，这一块的逻辑主要在 `calibrate()` ：\n\n```go\nfunc (p *Pool) calibrate() {\n    // 通过 CAS 确保同一时刻只有一个 goroutine 执行 calibrate\n    if !atomic.CompareAndSwapUint64(&p.calibrating, 0, 1) {\n        return\n    }\n\n    a := make(callSizes, 0, steps)\n    // 所有大小 buf 的总使用频次\n    var callsSum uint64\n    for i := uint64(0); i < steps; i++ {\n        calls := atomic.SwapUint64(&p.calls[i], 0)\n        callsSum += calls\n        a = append(a, callSize{\n            calls: calls,\n            size:  minSize << i,\n        })\n    }\n    // 按照使用频次从大到小排序\n    sort.Sort(a)\n\n    // 将 defaultSize 设置为频次最高的 size\n    defaultSize := a[0].size\n    maxSize := defaultSize\n\n    // 选择 maxSize，让 95% 的 buf 都能被归还到池中，只有最大的 %5 无法归还\n    maxSum := uint64(float64(callsSum) * maxPercentile)\n    callsSum = 0\n    for i := 0; i < steps; i++ {\n        if callsSum > maxSum {\n            break\n        }\n        callsSum += a[i].calls\n        size := a[i].size\n        if size > maxSize {\n            maxSize = size\n        }\n    }\n\n    // 因为 pool 会被多个 goroutine 访问，所以需要使用原子写入\n    atomic.StoreUint64(&p.defaultSize, defaultSize)\n    atomic.StoreUint64(&p.maxSize, maxSize)\n\n    atomic.StoreUint64(&p.calibrating, 0)\n}\n\ntype callSize struct {\n    calls uint64 // 使用频次\n    size  uint64 // buf 大小\n}\n\ntype callSizeSlice []callSize\n\nfunc (a callSizeSlice) Len() int           { return len(a) }\nfunc (a callSizeSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a callSizeSlice) Less(i, j int) bool { return a[i].calls > a[j].calls }\n```\n\n## 性能测试\n\n[pool_bench_test.go](https://github.com/MaoLongLong/bytebufferpool/blob/main/pool_bench_test.go)\n\n从上往下，分别为 ByteBufferPool, MinIO BytePoolCap 和普通 `[]byte`\n\n```bash\n$ go test -bench=Pool -benchmem\ngoos: linux\ngoarch: amd64\npkg: github.com/maolonglong/bytebufferpool\ncpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz\nBenchmarkByteBufferPoolBuf-4    20764896                52.71 ns/op            0 B/op          0 allocs/op\nBenchmarkBPool-4                 7899157               156.4 ns/op             0 B/op          0 allocs/op\nBenchmarkWithoutPool-4           4511701               270.5 ns/op          1472 B/op          3 allocs/op\nPASS\nok      github.com/maolonglong/bytebufferpool   4.091s\n```\n\n从测试结果可以看出，ByteBufferPool 不管在速度还是内存上都优于另外两种方案。\n\n## 总结\n\nGitHub 上许多优秀的项目其实代码并不难，通过这些项目可以学习大佬们设计、优化代码的思想，提升自己解决实际问题的能力。\n","source":"_posts/golang/bytebufferpool.md","raw":"---\ntitle: 高性能字节池 - bytebufferpool 源码分析\ndate: 2021-06-28 16:19:02\ncategories: Golang\ntags:\n  - pool\n---\n\n## 简介\n\n今天的主角是 [bytebufferpool](https://github.com/valyala/bytebufferpool) ，仓库的 README 文件是这么描述 bytebufferpool 的：\n\n> Currently bytebufferpool is fastest and most effective buffer pool written in Go.\n\n<!-- more -->\n\nbytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（[fasthttp](https://github.com/valyala/fasthttp), [quicktemplate](https://github.com/valyala/quicktemplate), [gnet](https://github.com/panjf2000/gnet)）\n\n什么是字节池？在读取文件或者从 `io.Reader` 获取数据时，一般都需要创建一个字节切片 `[]byte` 作为缓冲，如果对于这种方法有大量的调用，就会频繁地创建 `[]byte` ，这需要太多内存的申请和释放，增大了 GC 的压力。这个时候“池化”技术就派上了用场，通过复用对象以减少内存的分配和释放。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    r, _ := os.Open(\"./main.go\")\n    // 普通方式\n    buf := make([]byte, 64)\n    for {\n        n, err := r.Read(buf)\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            log.Fatal(err)\n        }\n        fmt.Print(string(buf[:n]))\n    }\n}\n```\n\n## 简单实现\n\n### MinIO BytePoolCap\n\nMinIO 中使用 `channel` 实现了一个非常简单的**有界**字节池 [bpool](https://github.com/minio/minio/blob/master/internal/bpool/bpool.go)\n\n```go\ntype BytePoolCap struct {\n    c    chan []byte\n    w    int\n    wcap int\n}\n\nfunc NewBytePoolCap(maxSize int, width int, capwidth int) (bp *BytePoolCap) {\n    return &BytePoolCap{\n        c:    make(chan []byte, maxSize),\n        w:    width,\n        wcap: capwidth,\n    }\n}\n```\n\n- `c` 用来存放字节切片（这也就是为什么**有界**的原因）\n- `w` 表示创建字节切片的 `len`\n- `wcap` 表示创建字节切片的 `cap`\n\n`Get()` 方法, 从池中获取字节切片：\n\n```go\nfunc (bp *BytePoolCap) Get() (b []byte) {\n    select {\n    case b = <-bp.c:\n        // channel 中存在 []byte 则复用\n    default:\n        // 否则创建 []byte\n        if bp.wcap > 0 {\n            b = make([]byte, bp.w, bp.wcap)\n        } else {\n            b = make([]byte, bp.w)\n        }\n    }\n    return\n}\n```\n\n`Put([]byte)` 方法，将使用完的切片放回池中，以被下一次获取：\n\n```go\nfunc (bp *BytePoolCap) Put(b []byte) {\n    select {\n    case bp.c <- b:\n        // channel 放得下\n    default:\n        // channel 放不下的话则不进行任何操作，直接丢弃这个 []byte\n    }\n}\n```\n\n使用示例\n\n```go\n// 多个 goroutine 公用一个 pool\nvar bp = bpool.NewBytePoolCap(100, 64, 64)\n\n// func ...\nbuf := bp.Get()\ndefer bp.Put(buf)\n\n// use buf ...\n```\n\n### sync.Pool\n\n谈到“池”，很容易想到 Go 标准库中的 `sync.Pool`，我们可以用几行代码就实现一个简单的字节池：\n\n```go\npool := &sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 64)\n    },\n}\n```\n\n然后就可以使用 `pool.Get().([]byte)` 从池中取字节切片，使用完后调用 `pool.Put(buf)` 归还到池中。\n\n## 问题分析\n\n上面的两种字节池实现都存在许多问题：池中新建的字节切片的 `len` 和 `cap` 都是创建池的时候固定的，不能动态修改。另外，如果往字节切片写入了大量数据（发生多次扩容），此时再将这样的字节切片放回池中，显然会造成内存浪费。\n\n所以需要解决的问题：\n\n1. 动态修改新分配字节切片的大小\n2. 阻止大切片放回字节池\n\n## ByteBufferPool\n\nByteBufferPool 中实现了一个类似 `bytes.Buffer` 的结构（[ByteBuffer](https://github.com/valyala/bytebufferpool/blob/master/bytebuffer.go)），它封装了一些对 `[]byte` 的复杂操作，从 benchmark 的结果可以看出它的性能比 `bytes.Buffer` 略高一些，但它不是字节池的重点，所以就不贴代码了。\n\nByteBufferPool 是怎么解决上述问题的？\n\n```go\nconst (\n    minBitSize = 6  // 2**6=64 is a CPU cache line size\n\n    // 将 buf 的大小划分为 20 个区间\n    // ==> (0, 64], (64, 128], (128, 256], ... , (8388608, 16777216], (16777216, 33554432]\n    // 超过 33554432 的也属于最后一个区间\n    steps = 20\n\n    minSize = 1 << minBitSize               // 64\n    maxSize = 1 << (minBitSize + steps - 1) // 33554432\n\n    calibrateCallsThreshold = 42000\n    maxPercentile           = 0.95\n)\n\ntype Pool struct {\n    calls       [steps]uint64 // 不同大小 buf 的使用频次\n    calibrating uint64        // 标记是否正在校准（校准过程就是调整 defaultSize 和 maxSize）\n\n    defaultSize uint64 // make []byte 时的 cap\n    maxSize     uint64 // 能放回池中的最大 buf 大小\n\n    pool sync.Pool // 存储 buf\n}\n\nfunc (p *Pool) Get() *ByteBuffer {\n    v := p.pool.Get()\n    // 如果池中有 buf 直接返回\n    if v != nil {\n        return v.(*ByteBuffer)\n    }\n    // 否则新建一个 cap 为 defaultSize 的 buf\n    return &ByteBuffer{\n        B: make([]byte, 0, atomic.LoadUint64(&p.defaultSize)),\n    }\n}\n```\n\n继续查看 `Put()`，从这就可以看出 ByteBufferPool 的主要逻辑了：\n\n```go\nfunc (p *Pool) Put(b *ByteBuffer) {\n    // len 所在 “区间” 的下标\n    idx := index(len(b.B))\n\n    // 解决了问题1：动态调整 size\n    // 使用频次加1，如果超过了阈值（42000）则进行校准\n    if atomic.AddUint64(&p.calls[idx], 1) > calibrateCallsThreshold {\n        p.calibrate()\n    }\n\n    // 解决了问题2：阻止大切片放回字节池\n    // 如果还未设置 maxSize 或 cap 小于等于 maxSize 才执行 Put\n    maxSize := int(atomic.LoadUint64(&p.maxSize))\n    if maxSize == 0 || cap(b.B) <= maxSize {\n        b.Reset()\n        p.pool.Put(b)\n    }\n}\n\nfunc index(n int) int {\n    n--\n    n >>= minBitSize\n    idx := 0\n    for n > 0 {\n        n >>= 1\n        idx++\n    }\n    if idx >= steps {\n        idx = steps - 1\n    }\n    return idx\n}\n```\n\n划分区间的目的就是方便统计出程序近一段时间内**最经常使用**多大的 buf，从而决定 `defaultSize` 和 `maxSize`，这一块的逻辑主要在 `calibrate()` ：\n\n```go\nfunc (p *Pool) calibrate() {\n    // 通过 CAS 确保同一时刻只有一个 goroutine 执行 calibrate\n    if !atomic.CompareAndSwapUint64(&p.calibrating, 0, 1) {\n        return\n    }\n\n    a := make(callSizes, 0, steps)\n    // 所有大小 buf 的总使用频次\n    var callsSum uint64\n    for i := uint64(0); i < steps; i++ {\n        calls := atomic.SwapUint64(&p.calls[i], 0)\n        callsSum += calls\n        a = append(a, callSize{\n            calls: calls,\n            size:  minSize << i,\n        })\n    }\n    // 按照使用频次从大到小排序\n    sort.Sort(a)\n\n    // 将 defaultSize 设置为频次最高的 size\n    defaultSize := a[0].size\n    maxSize := defaultSize\n\n    // 选择 maxSize，让 95% 的 buf 都能被归还到池中，只有最大的 %5 无法归还\n    maxSum := uint64(float64(callsSum) * maxPercentile)\n    callsSum = 0\n    for i := 0; i < steps; i++ {\n        if callsSum > maxSum {\n            break\n        }\n        callsSum += a[i].calls\n        size := a[i].size\n        if size > maxSize {\n            maxSize = size\n        }\n    }\n\n    // 因为 pool 会被多个 goroutine 访问，所以需要使用原子写入\n    atomic.StoreUint64(&p.defaultSize, defaultSize)\n    atomic.StoreUint64(&p.maxSize, maxSize)\n\n    atomic.StoreUint64(&p.calibrating, 0)\n}\n\ntype callSize struct {\n    calls uint64 // 使用频次\n    size  uint64 // buf 大小\n}\n\ntype callSizeSlice []callSize\n\nfunc (a callSizeSlice) Len() int           { return len(a) }\nfunc (a callSizeSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a callSizeSlice) Less(i, j int) bool { return a[i].calls > a[j].calls }\n```\n\n## 性能测试\n\n[pool_bench_test.go](https://github.com/MaoLongLong/bytebufferpool/blob/main/pool_bench_test.go)\n\n从上往下，分别为 ByteBufferPool, MinIO BytePoolCap 和普通 `[]byte`\n\n```bash\n$ go test -bench=Pool -benchmem\ngoos: linux\ngoarch: amd64\npkg: github.com/maolonglong/bytebufferpool\ncpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz\nBenchmarkByteBufferPoolBuf-4    20764896                52.71 ns/op            0 B/op          0 allocs/op\nBenchmarkBPool-4                 7899157               156.4 ns/op             0 B/op          0 allocs/op\nBenchmarkWithoutPool-4           4511701               270.5 ns/op          1472 B/op          3 allocs/op\nPASS\nok      github.com/maolonglong/bytebufferpool   4.091s\n```\n\n从测试结果可以看出，ByteBufferPool 不管在速度还是内存上都优于另外两种方案。\n\n## 总结\n\nGitHub 上许多优秀的项目其实代码并不难，通过这些项目可以学习大佬们设计、优化代码的思想，提升自己解决实际问题的能力。\n","slug":"golang/bytebufferpool","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdg0003xeoa9vcz2koq","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>今天的主角是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2w=\">bytebufferpool<i class=\"fa fa-external-link-alt\"></i></span> ，仓库的 README 文件是这么描述 bytebufferpool 的：</p>\n<blockquote>\n<p>Currently bytebufferpool is fastest and most effective buffer pool written in Go.</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>bytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvZmFzdGh0dHA=\">fasthttp<i class=\"fa fa-external-link-alt\"></i></span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvcXVpY2t0ZW1wbGF0ZQ==\">quicktemplate<i class=\"fa fa-external-link-alt\"></i></span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3BhbmpmMjAwMC9nbmV0\">gnet<i class=\"fa fa-external-link-alt\"></i></span>）</p>\n<p>什么是字节池？在读取文件或者从 <code>io.Reader</code> 获取数据时，一般都需要创建一个字节切片 <code>[]byte</code> 作为缓冲，如果对于这种方法有大量的调用，就会频繁地创建 <code>[]byte</code> ，这需要太多内存的申请和释放，增大了 GC 的压力。这个时候“池化”技术就派上了用场，通过复用对象以减少内存的分配和释放。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    r, _ := os.Open(<span class=\"string\">&quot;./main.go&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 普通方式</span></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        n, err := r.Read(buf)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.Fatal(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Print(<span class=\"type\">string</span>(buf[:n]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><h3 id=\"MinIO-BytePoolCap\"><a href=\"#MinIO-BytePoolCap\" class=\"headerlink\" title=\"MinIO BytePoolCap\"></a>MinIO BytePoolCap</h3><p>MinIO 中使用 <code>channel</code> 实现了一个非常简单的<strong>有界</strong>字节池 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pbmlvL21pbmlvL2Jsb2IvbWFzdGVyL2ludGVybmFsL2Jwb29sL2Jwb29sLmdv\">bpool<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BytePoolCap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    c    <span class=\"keyword\">chan</span> []<span class=\"type\">byte</span></span><br><span class=\"line\">    w    <span class=\"type\">int</span></span><br><span class=\"line\">    wcap <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBytePoolCap</span><span class=\"params\">(maxSize <span class=\"type\">int</span>, width <span class=\"type\">int</span>, capwidth <span class=\"type\">int</span>)</span></span> (bp *BytePoolCap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;BytePoolCap&#123;</span><br><span class=\"line\">        c:    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> []<span class=\"type\">byte</span>, maxSize),</span><br><span class=\"line\">        w:    width,</span><br><span class=\"line\">        wcap: capwidth,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>c</code> 用来存放字节切片（这也就是为什么<strong>有界</strong>的原因）</li>\n<li><code>w</code> 表示创建字节切片的 <code>len</code></li>\n<li><code>wcap</code> 表示创建字节切片的 <code>cap</code></li>\n</ul>\n<p><code>Get()</code> 方法, 从池中获取字节切片：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bp *BytePoolCap)</span></span> Get() (b []<span class=\"type\">byte</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> b = &lt;-bp.c:</span><br><span class=\"line\">        <span class=\"comment\">// channel 中存在 []byte 则复用</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 否则创建 []byte</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> bp.wcap &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            b = <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, bp.w, bp.wcap)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            b = <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, bp.w)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Put([]byte)</code> 方法，将使用完的切片放回池中，以被下一次获取：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bp *BytePoolCap)</span></span> Put(b []<span class=\"type\">byte</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> bp.c &lt;- b:</span><br><span class=\"line\">        <span class=\"comment\">// channel 放得下</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// channel 放不下的话则不进行任何操作，直接丢弃这个 []byte</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多个 goroutine 公用一个 pool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bp = bpool.NewBytePoolCap(<span class=\"number\">100</span>, <span class=\"number\">64</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func ...</span></span><br><span class=\"line\">buf := bp.Get()</span><br><span class=\"line\"><span class=\"keyword\">defer</span> bp.Put(buf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use buf ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sync-Pool\"><a href=\"#sync-Pool\" class=\"headerlink\" title=\"sync.Pool\"></a>sync.Pool</h3><p>谈到“池”，很容易想到 Go 标准库中的 <code>sync.Pool</code>，我们可以用几行代码就实现一个简单的字节池：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pool := &amp;sync.Pool&#123;</span><br><span class=\"line\">    New: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以使用 <code>pool.Get().([]byte)</code> 从池中取字节切片，使用完后调用 <code>pool.Put(buf)</code> 归还到池中。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>上面的两种字节池实现都存在许多问题：池中新建的字节切片的 <code>len</code> 和 <code>cap</code> 都是创建池的时候固定的，不能动态修改。另外，如果往字节切片写入了大量数据（发生多次扩容），此时再将这样的字节切片放回池中，显然会造成内存浪费。</p>\n<p>所以需要解决的问题：</p>\n<ol>\n<li>动态修改新分配字节切片的大小</li>\n<li>阻止大切片放回字节池</li>\n</ol>\n<h2 id=\"ByteBufferPool\"><a href=\"#ByteBufferPool\" class=\"headerlink\" title=\"ByteBufferPool\"></a>ByteBufferPool</h2><p>ByteBufferPool 中实现了一个类似 <code>bytes.Buffer</code> 的结构（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2wvYmxvYi9tYXN0ZXIvYnl0ZWJ1ZmZlci5nbw==\">ByteBuffer<i class=\"fa fa-external-link-alt\"></i></span>），它封装了一些对 <code>[]byte</code> 的复杂操作，从 benchmark 的结果可以看出它的性能比 <code>bytes.Buffer</code> 略高一些，但它不是字节池的重点，所以就不贴代码了。</p>\n<p>ByteBufferPool 是怎么解决上述问题的？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    minBitSize = <span class=\"number\">6</span>  <span class=\"comment\">// 2**6=64 is a CPU cache line size</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 buf 的大小划分为 20 个区间</span></span><br><span class=\"line\">    <span class=\"comment\">// ==&gt; (0, 64], (64, 128], (128, 256], ... , (8388608, 16777216], (16777216, 33554432]</span></span><br><span class=\"line\">    <span class=\"comment\">// 超过 33554432 的也属于最后一个区间</span></span><br><span class=\"line\">    steps = <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">    minSize = <span class=\"number\">1</span> &lt;&lt; minBitSize               <span class=\"comment\">// 64</span></span><br><span class=\"line\">    maxSize = <span class=\"number\">1</span> &lt;&lt; (minBitSize + steps - <span class=\"number\">1</span>) <span class=\"comment\">// 33554432</span></span><br><span class=\"line\"></span><br><span class=\"line\">    calibrateCallsThreshold = <span class=\"number\">42000</span></span><br><span class=\"line\">    maxPercentile           = <span class=\"number\">0.95</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    calls       [steps]<span class=\"type\">uint64</span> <span class=\"comment\">// 不同大小 buf 的使用频次</span></span><br><span class=\"line\">    calibrating <span class=\"type\">uint64</span>        <span class=\"comment\">// 标记是否正在校准（校准过程就是调整 defaultSize 和 maxSize）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    defaultSize <span class=\"type\">uint64</span> <span class=\"comment\">// make []byte 时的 cap</span></span><br><span class=\"line\">    maxSize     <span class=\"type\">uint64</span> <span class=\"comment\">// 能放回池中的最大 buf 大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pool sync.Pool <span class=\"comment\">// 存储 buf</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> Get() *ByteBuffer &#123;</span><br><span class=\"line\">    v := p.pool.Get()</span><br><span class=\"line\">    <span class=\"comment\">// 如果池中有 buf 直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.(*ByteBuffer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则新建一个 cap 为 defaultSize 的 buf</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;ByteBuffer&#123;</span><br><span class=\"line\">        B: <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">0</span>, atomic.LoadUint64(&amp;p.defaultSize)),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续查看 <code>Put()</code>，从这就可以看出 ByteBufferPool 的主要逻辑了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> Put(b *ByteBuffer) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// len 所在 “区间” 的下标</span></span><br><span class=\"line\">    idx := index(<span class=\"built_in\">len</span>(b.B))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解决了问题1：动态调整 size</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用频次加1，如果超过了阈值（42000）则进行校准</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> atomic.AddUint64(&amp;p.calls[idx], <span class=\"number\">1</span>) &gt; calibrateCallsThreshold &#123;</span><br><span class=\"line\">        p.calibrate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解决了问题2：阻止大切片放回字节池</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果还未设置 maxSize 或 cap 小于等于 maxSize 才执行 Put</span></span><br><span class=\"line\">    maxSize := <span class=\"type\">int</span>(atomic.LoadUint64(&amp;p.maxSize))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxSize == <span class=\"number\">0</span> || <span class=\"built_in\">cap</span>(b.B) &lt;= maxSize &#123;</span><br><span class=\"line\">        b.Reset()</span><br><span class=\"line\">        p.pool.Put(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n--</span><br><span class=\"line\">    n &gt;&gt;= minBitSize</span><br><span class=\"line\">    idx := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        idx++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx &gt;= steps &#123;</span><br><span class=\"line\">        idx = steps - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> idx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分区间的目的就是方便统计出程序近一段时间内<strong>最经常使用</strong>多大的 buf，从而决定 <code>defaultSize</code> 和 <code>maxSize</code>，这一块的逻辑主要在 <code>calibrate()</code> ：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> calibrate() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 CAS 确保同一时刻只有一个 goroutine 执行 calibrate</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !atomic.CompareAndSwapUint64(&amp;p.calibrating, <span class=\"number\">0</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    a := <span class=\"built_in\">make</span>(callSizes, <span class=\"number\">0</span>, steps)</span><br><span class=\"line\">    <span class=\"comment\">// 所有大小 buf 的总使用频次</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> callsSum <span class=\"type\">uint64</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"type\">uint64</span>(<span class=\"number\">0</span>); i &lt; steps; i++ &#123;</span><br><span class=\"line\">        calls := atomic.SwapUint64(&amp;p.calls[i], <span class=\"number\">0</span>)</span><br><span class=\"line\">        callsSum += calls</span><br><span class=\"line\">        a = <span class=\"built_in\">append</span>(a, callSize&#123;</span><br><span class=\"line\">            calls: calls,</span><br><span class=\"line\">            size:  minSize &lt;&lt; i,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 按照使用频次从大到小排序</span></span><br><span class=\"line\">    sort.Sort(a)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 defaultSize 设置为频次最高的 size</span></span><br><span class=\"line\">    defaultSize := a[<span class=\"number\">0</span>].size</span><br><span class=\"line\">    maxSize := defaultSize</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 选择 maxSize，让 95% 的 buf 都能被归还到池中，只有最大的 %5 无法归还</span></span><br><span class=\"line\">    maxSum := <span class=\"type\">uint64</span>(<span class=\"type\">float64</span>(callsSum) * maxPercentile)</span><br><span class=\"line\">    callsSum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; steps; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> callsSum &gt; maxSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callsSum += a[i].calls</span><br><span class=\"line\">        size := a[i].size</span><br><span class=\"line\">        <span class=\"keyword\">if</span> size &gt; maxSize &#123;</span><br><span class=\"line\">            maxSize = size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因为 pool 会被多个 goroutine 访问，所以需要使用原子写入</span></span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.defaultSize, defaultSize)</span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.maxSize, maxSize)</span><br><span class=\"line\"></span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.calibrating, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> callSize <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    calls <span class=\"type\">uint64</span> <span class=\"comment\">// 使用频次</span></span><br><span class=\"line\">    size  <span class=\"type\">uint64</span> <span class=\"comment\">// buf 大小</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> callSizeSlice []callSize</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Len() <span class=\"type\">int</span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(a) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> a[i].calls &gt; a[j].calls &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01hb0xvbmdMb25nL2J5dGVidWZmZXJwb29sL2Jsb2IvbWFpbi9wb29sX2JlbmNoX3Rlc3QuZ28=\">pool_bench_test.go<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>从上往下，分别为 ByteBufferPool, MinIO BytePoolCap 和普通 <code>[]byte</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -bench=Pool -benchmem</span><br><span class=\"line\">goos: linux</span><br><span class=\"line\">goarch: amd64</span><br><span class=\"line\">pkg: github.com/maolonglong/bytebufferpool</span><br><span class=\"line\">cpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz</span><br><span class=\"line\">BenchmarkByteBufferPoolBuf-4    20764896                52.71 ns/op            0 B/op          0 allocs/op</span><br><span class=\"line\">BenchmarkBPool-4                 7899157               156.4 ns/op             0 B/op          0 allocs/op</span><br><span class=\"line\">BenchmarkWithoutPool-4           4511701               270.5 ns/op          1472 B/op          3 allocs/op</span><br><span class=\"line\">PASS</span><br><span class=\"line\">ok      github.com/maolonglong/bytebufferpool   4.091s</span><br></pre></td></tr></table></figure>\n\n<p>从测试结果可以看出，ByteBufferPool 不管在速度还是内存上都优于另外两种方案。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>GitHub 上许多优秀的项目其实代码并不难，通过这些项目可以学习大佬们设计、优化代码的思想，提升自己解决实际问题的能力。</p>\n","site":{"data":{}},"length":5018,"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>今天的主角是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2w=\">bytebufferpool<i class=\"fa fa-external-link-alt\"></i></span> ，仓库的 README 文件是这么描述 bytebufferpool 的：</p>\n<blockquote>\n<p>Currently bytebufferpool is fastest and most effective buffer pool written in Go.</p>\n</blockquote>","more":"<p>bytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvZmFzdGh0dHA=\">fasthttp<i class=\"fa fa-external-link-alt\"></i></span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvcXVpY2t0ZW1wbGF0ZQ==\">quicktemplate<i class=\"fa fa-external-link-alt\"></i></span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3BhbmpmMjAwMC9nbmV0\">gnet<i class=\"fa fa-external-link-alt\"></i></span>）</p>\n<p>什么是字节池？在读取文件或者从 <code>io.Reader</code> 获取数据时，一般都需要创建一个字节切片 <code>[]byte</code> 作为缓冲，如果对于这种方法有大量的调用，就会频繁地创建 <code>[]byte</code> ，这需要太多内存的申请和释放，增大了 GC 的压力。这个时候“池化”技术就派上了用场，通过复用对象以减少内存的分配和释放。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    r, _ := os.Open(<span class=\"string\">&quot;./main.go&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 普通方式</span></span><br><span class=\"line\">    buf := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        n, err := r.Read(buf)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.Fatal(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Print(<span class=\"type\">string</span>(buf[:n]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><h3 id=\"MinIO-BytePoolCap\"><a href=\"#MinIO-BytePoolCap\" class=\"headerlink\" title=\"MinIO BytePoolCap\"></a>MinIO BytePoolCap</h3><p>MinIO 中使用 <code>channel</code> 实现了一个非常简单的<strong>有界</strong>字节池 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pbmlvL21pbmlvL2Jsb2IvbWFzdGVyL2ludGVybmFsL2Jwb29sL2Jwb29sLmdv\">bpool<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BytePoolCap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    c    <span class=\"keyword\">chan</span> []<span class=\"type\">byte</span></span><br><span class=\"line\">    w    <span class=\"type\">int</span></span><br><span class=\"line\">    wcap <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBytePoolCap</span><span class=\"params\">(maxSize <span class=\"type\">int</span>, width <span class=\"type\">int</span>, capwidth <span class=\"type\">int</span>)</span></span> (bp *BytePoolCap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;BytePoolCap&#123;</span><br><span class=\"line\">        c:    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> []<span class=\"type\">byte</span>, maxSize),</span><br><span class=\"line\">        w:    width,</span><br><span class=\"line\">        wcap: capwidth,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>c</code> 用来存放字节切片（这也就是为什么<strong>有界</strong>的原因）</li>\n<li><code>w</code> 表示创建字节切片的 <code>len</code></li>\n<li><code>wcap</code> 表示创建字节切片的 <code>cap</code></li>\n</ul>\n<p><code>Get()</code> 方法, 从池中获取字节切片：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bp *BytePoolCap)</span></span> Get() (b []<span class=\"type\">byte</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> b = &lt;-bp.c:</span><br><span class=\"line\">        <span class=\"comment\">// channel 中存在 []byte 则复用</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 否则创建 []byte</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> bp.wcap &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            b = <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, bp.w, bp.wcap)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            b = <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, bp.w)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Put([]byte)</code> 方法，将使用完的切片放回池中，以被下一次获取：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(bp *BytePoolCap)</span></span> Put(b []<span class=\"type\">byte</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> bp.c &lt;- b:</span><br><span class=\"line\">        <span class=\"comment\">// channel 放得下</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// channel 放不下的话则不进行任何操作，直接丢弃这个 []byte</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多个 goroutine 公用一个 pool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bp = bpool.NewBytePoolCap(<span class=\"number\">100</span>, <span class=\"number\">64</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func ...</span></span><br><span class=\"line\">buf := bp.Get()</span><br><span class=\"line\"><span class=\"keyword\">defer</span> bp.Put(buf)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use buf ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sync-Pool\"><a href=\"#sync-Pool\" class=\"headerlink\" title=\"sync.Pool\"></a>sync.Pool</h3><p>谈到“池”，很容易想到 Go 标准库中的 <code>sync.Pool</code>，我们可以用几行代码就实现一个简单的字节池：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pool := &amp;sync.Pool&#123;</span><br><span class=\"line\">    New: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以使用 <code>pool.Get().([]byte)</code> 从池中取字节切片，使用完后调用 <code>pool.Put(buf)</code> 归还到池中。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>上面的两种字节池实现都存在许多问题：池中新建的字节切片的 <code>len</code> 和 <code>cap</code> 都是创建池的时候固定的，不能动态修改。另外，如果往字节切片写入了大量数据（发生多次扩容），此时再将这样的字节切片放回池中，显然会造成内存浪费。</p>\n<p>所以需要解决的问题：</p>\n<ol>\n<li>动态修改新分配字节切片的大小</li>\n<li>阻止大切片放回字节池</li>\n</ol>\n<h2 id=\"ByteBufferPool\"><a href=\"#ByteBufferPool\" class=\"headerlink\" title=\"ByteBufferPool\"></a>ByteBufferPool</h2><p>ByteBufferPool 中实现了一个类似 <code>bytes.Buffer</code> 的结构（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhbHlhbGEvYnl0ZWJ1ZmZlcnBvb2wvYmxvYi9tYXN0ZXIvYnl0ZWJ1ZmZlci5nbw==\">ByteBuffer<i class=\"fa fa-external-link-alt\"></i></span>），它封装了一些对 <code>[]byte</code> 的复杂操作，从 benchmark 的结果可以看出它的性能比 <code>bytes.Buffer</code> 略高一些，但它不是字节池的重点，所以就不贴代码了。</p>\n<p>ByteBufferPool 是怎么解决上述问题的？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    minBitSize = <span class=\"number\">6</span>  <span class=\"comment\">// 2**6=64 is a CPU cache line size</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 buf 的大小划分为 20 个区间</span></span><br><span class=\"line\">    <span class=\"comment\">// ==&gt; (0, 64], (64, 128], (128, 256], ... , (8388608, 16777216], (16777216, 33554432]</span></span><br><span class=\"line\">    <span class=\"comment\">// 超过 33554432 的也属于最后一个区间</span></span><br><span class=\"line\">    steps = <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">    minSize = <span class=\"number\">1</span> &lt;&lt; minBitSize               <span class=\"comment\">// 64</span></span><br><span class=\"line\">    maxSize = <span class=\"number\">1</span> &lt;&lt; (minBitSize + steps - <span class=\"number\">1</span>) <span class=\"comment\">// 33554432</span></span><br><span class=\"line\"></span><br><span class=\"line\">    calibrateCallsThreshold = <span class=\"number\">42000</span></span><br><span class=\"line\">    maxPercentile           = <span class=\"number\">0.95</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    calls       [steps]<span class=\"type\">uint64</span> <span class=\"comment\">// 不同大小 buf 的使用频次</span></span><br><span class=\"line\">    calibrating <span class=\"type\">uint64</span>        <span class=\"comment\">// 标记是否正在校准（校准过程就是调整 defaultSize 和 maxSize）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    defaultSize <span class=\"type\">uint64</span> <span class=\"comment\">// make []byte 时的 cap</span></span><br><span class=\"line\">    maxSize     <span class=\"type\">uint64</span> <span class=\"comment\">// 能放回池中的最大 buf 大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pool sync.Pool <span class=\"comment\">// 存储 buf</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> Get() *ByteBuffer &#123;</span><br><span class=\"line\">    v := p.pool.Get()</span><br><span class=\"line\">    <span class=\"comment\">// 如果池中有 buf 直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.(*ByteBuffer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则新建一个 cap 为 defaultSize 的 buf</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;ByteBuffer&#123;</span><br><span class=\"line\">        B: <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">0</span>, atomic.LoadUint64(&amp;p.defaultSize)),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续查看 <code>Put()</code>，从这就可以看出 ByteBufferPool 的主要逻辑了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> Put(b *ByteBuffer) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// len 所在 “区间” 的下标</span></span><br><span class=\"line\">    idx := index(<span class=\"built_in\">len</span>(b.B))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解决了问题1：动态调整 size</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用频次加1，如果超过了阈值（42000）则进行校准</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> atomic.AddUint64(&amp;p.calls[idx], <span class=\"number\">1</span>) &gt; calibrateCallsThreshold &#123;</span><br><span class=\"line\">        p.calibrate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解决了问题2：阻止大切片放回字节池</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果还未设置 maxSize 或 cap 小于等于 maxSize 才执行 Put</span></span><br><span class=\"line\">    maxSize := <span class=\"type\">int</span>(atomic.LoadUint64(&amp;p.maxSize))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxSize == <span class=\"number\">0</span> || <span class=\"built_in\">cap</span>(b.B) &lt;= maxSize &#123;</span><br><span class=\"line\">        b.Reset()</span><br><span class=\"line\">        p.pool.Put(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n--</span><br><span class=\"line\">    n &gt;&gt;= minBitSize</span><br><span class=\"line\">    idx := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        idx++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> idx &gt;= steps &#123;</span><br><span class=\"line\">        idx = steps - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> idx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>划分区间的目的就是方便统计出程序近一段时间内<strong>最经常使用</strong>多大的 buf，从而决定 <code>defaultSize</code> 和 <code>maxSize</code>，这一块的逻辑主要在 <code>calibrate()</code> ：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pool)</span></span> calibrate() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 CAS 确保同一时刻只有一个 goroutine 执行 calibrate</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !atomic.CompareAndSwapUint64(&amp;p.calibrating, <span class=\"number\">0</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    a := <span class=\"built_in\">make</span>(callSizes, <span class=\"number\">0</span>, steps)</span><br><span class=\"line\">    <span class=\"comment\">// 所有大小 buf 的总使用频次</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> callsSum <span class=\"type\">uint64</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"type\">uint64</span>(<span class=\"number\">0</span>); i &lt; steps; i++ &#123;</span><br><span class=\"line\">        calls := atomic.SwapUint64(&amp;p.calls[i], <span class=\"number\">0</span>)</span><br><span class=\"line\">        callsSum += calls</span><br><span class=\"line\">        a = <span class=\"built_in\">append</span>(a, callSize&#123;</span><br><span class=\"line\">            calls: calls,</span><br><span class=\"line\">            size:  minSize &lt;&lt; i,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 按照使用频次从大到小排序</span></span><br><span class=\"line\">    sort.Sort(a)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 defaultSize 设置为频次最高的 size</span></span><br><span class=\"line\">    defaultSize := a[<span class=\"number\">0</span>].size</span><br><span class=\"line\">    maxSize := defaultSize</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 选择 maxSize，让 95% 的 buf 都能被归还到池中，只有最大的 %5 无法归还</span></span><br><span class=\"line\">    maxSum := <span class=\"type\">uint64</span>(<span class=\"type\">float64</span>(callsSum) * maxPercentile)</span><br><span class=\"line\">    callsSum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; steps; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> callsSum &gt; maxSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callsSum += a[i].calls</span><br><span class=\"line\">        size := a[i].size</span><br><span class=\"line\">        <span class=\"keyword\">if</span> size &gt; maxSize &#123;</span><br><span class=\"line\">            maxSize = size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因为 pool 会被多个 goroutine 访问，所以需要使用原子写入</span></span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.defaultSize, defaultSize)</span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.maxSize, maxSize)</span><br><span class=\"line\"></span><br><span class=\"line\">    atomic.StoreUint64(&amp;p.calibrating, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> callSize <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    calls <span class=\"type\">uint64</span> <span class=\"comment\">// 使用频次</span></span><br><span class=\"line\">    size  <span class=\"type\">uint64</span> <span class=\"comment\">// buf 大小</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> callSizeSlice []callSize</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Len() <span class=\"type\">int</span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(a) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a callSizeSlice)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> a[i].calls &gt; a[j].calls &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01hb0xvbmdMb25nL2J5dGVidWZmZXJwb29sL2Jsb2IvbWFpbi9wb29sX2JlbmNoX3Rlc3QuZ28=\">pool_bench_test.go<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>从上往下，分别为 ByteBufferPool, MinIO BytePoolCap 和普通 <code>[]byte</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -bench=Pool -benchmem</span><br><span class=\"line\">goos: linux</span><br><span class=\"line\">goarch: amd64</span><br><span class=\"line\">pkg: github.com/maolonglong/bytebufferpool</span><br><span class=\"line\">cpu: Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz</span><br><span class=\"line\">BenchmarkByteBufferPoolBuf-4    20764896                52.71 ns/op            0 B/op          0 allocs/op</span><br><span class=\"line\">BenchmarkBPool-4                 7899157               156.4 ns/op             0 B/op          0 allocs/op</span><br><span class=\"line\">BenchmarkWithoutPool-4           4511701               270.5 ns/op          1472 B/op          3 allocs/op</span><br><span class=\"line\">PASS</span><br><span class=\"line\">ok      github.com/maolonglong/bytebufferpool   4.091s</span><br></pre></td></tr></table></figure>\n\n<p>从测试结果可以看出，ByteBufferPool 不管在速度还是内存上都优于另外两种方案。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>GitHub 上许多优秀的项目其实代码并不难，通过这些项目可以学习大佬们设计、优化代码的思想，提升自己解决实际问题的能力。</p>"},{"title":"熔断器模式","date":"2021-09-16T08:21:28.000Z","_content":"\n熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。\n\n## 背景和问题\n\n在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。\n\n此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是**立即**让调用失败，只有在可能成功时才尝试调用服务。\n\n<!-- more -->\n\n{% note warning %}\n设置一个更短的超时可能有助于解决这个问题，但是超时不应该太短，这可能会让那些本来应该成功的请求也超时。\n{% endnote %}\n\n## 解决\n\n熔断器作为一个可能失败操作的代理，监控最近发生故障的数量，然后使用这些信息来决定是否允许操作继续，防止应用程序反复执行失败操作。\n\n熔断器本质上就是一个**状态机**，它具有以下状态：\n\n- **Closed：**程序可以正常发出请求，熔断器维护最近失败的次数，如果操作调用不成功，则熔断器增加此计数。如果在给定时间内，失败次数超过了指定的阈值，状态机将变为 **Open** 状态。此时，启动一个计时器，在一定时间后，状态机变为 **Half-Open** 状态。\n- **Open：**程序发出的请求会立即失败，并向程序返回异常。（相当于电闸跳闸了）\n- **Half-Open：**程序只能执行有限数量的请求操作，如果这些请求成功了（故障已经恢复），状态机变为 **Closed** 状态。如果请求失败了，状态机变为 **Open** 状态，并且重新启动计时器。\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161309094.png)\n\n## Golang 实现\n\n[![gobreaker](https://github-readme-stats.vercel.app/api/pin/?username=sony&repo=gobreaker&show_owner=true)](https://github.com/sony/gobreaker)\n\n### 使用\n\n我们可以通过 `Settings` 结构体配置熔断器：\n\n```go\ntype Settings struct {\n    Name          string\n    MaxRequests   uint32\n    Interval      time.Duration\n    Timeout       time.Duration\n    ReadyToTrip   func(counts Counts) bool\n    OnStateChange func(name string, from State, to State)\n}\n```\n\n- `MaxRequests`: **Half-Open** 状态下的最大请求次数，默认为 1\n- `Interval`: **Closed** 状态下清空计数器的周期，默认不清空\n- `Timeout`: **Open** 状态转 **Half-Open** 状态的时间，默认 60 秒\n- `ReadyToTrip`: 通过计数器的信息判断是否需要熔断，默认连续失败 5 次后熔断\n- `OnStateChange`: 状态变化时的回调\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"log\"\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/sony/gobreaker\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings{\n        ReadyToTrip: func(counts gobreaker.Counts) bool {\n            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n            // 失败率大于 60% 时熔断\n            return counts.Requests >= 3 && failureRatio >= 0.6\n        },\n        OnStateChange: func(_ string, from, to gobreaker.State) {\n            log.Printf(\"from: %v, to: %v\\n\", from, to)\n        },\n    })\n\n    for {\n        result, err := cb.Execute(func() (interface{}, error) {\n            // 模拟 70% 的失败率\n            if rand.Float64() < 0.7 {\n                return nil, errors.New(\"some error\")\n            }\n            return \"ok\", nil\n        })\n        log.Printf(\"result: %v, err: %v\\n\", result, err)\n        time.Sleep(time.Second)\n    }\n}\n```\n\n运行结果：\n\n```bash\n$ go run main.go\n2021/09/16 15:23:24 result: <nil>, err: some error\n2021/09/16 15:23:25 result: <nil>, err: some error\n2021/09/16 15:23:26 from: closed, to: open\n2021/09/16 15:23:26 result: <nil>, err: some error\n2021/09/16 15:23:27 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:28 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:29 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:30 result: <nil>, err: circuit breaker is open\n......\n```\n\n### Execute 流程\n\n简单过一遍 `Execute()` 的流程，详细代码可以看 [gobreader.go](https://github.com/sony/gobreaker/blob/master/gobreaker.go)，不到 400 行，实现的非常简洁。\n\n```go\nfunc (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {\n    // 增加计数，判断状态\n    generation, err := cb.beforeRequest()\n    if err != nil {\n        // 如果熔断器已经 Open，在这里就会直接返回 ErrOpenState\n        // Half-Open 状态下超过最大请求数则返回 ErrTooManyRequests\n        return nil, err\n    }\n\n    defer func() {\n        e := recover()\n        if e != nil {\n            cb.afterRequest(generation, false)\n            panic(e)\n        }\n    }()\n\n    // 执行真正的操作\n    result, err := req()\n\n    // 增加计数，达到阈值就熔断，err 非空表示失败\n    cb.afterRequest(generation, err == nil)\n    return result, err\n}\n```\n\n从上面的源码，我们可以看出，执行过程只是简单地通过 `err == nil` 判断成功，假设业务的逻辑很复杂，需要加入自定义的判断，可以用 `TwoStepCircuitBreaker`。\n\n### 两阶段熔断\n\n和普通熔断器的使用差不多，`Allow()` 方法只是调用了 `beforeRequest()`，然后返回回调函数 `done(success bool)` 和错误信息，通过回调函数我们能把操作成功与否告诉熔断器。\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/sony/gobreaker\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    cb := gobreaker.NewTwoStepCircuitBreaker(gobreaker.Settings{\n        ReadyToTrip: func(counts gobreaker.Counts) bool {\n            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n            return counts.Requests >= 3 && failureRatio >= 0.6\n        },\n        OnStateChange: func(_ string, from, to gobreaker.State) {\n            log.Printf(\"from: %v, to: %v\\n\", from, to)\n        },\n    })\n\n    for {\n        time.Sleep(time.Second)\n        done, err := cb.Allow()\n        if err != nil {\n            log.Printf(\"err: %v\\n\", err)\n            continue\n        }\n        success := true\n        if rand.Float64() < 0.7 {\n            log.Println(\"failure\")\n            success = false\n        } else {\n            log.Println(\"success\")\n        }\n        done(success)\n    }\n}\n```\n\n运行结果：\n\n```bash\n$ go run main.go\n2021/09/16 16:26:49 failure\n2021/09/16 16:26:50 failure\n2021/09/16 16:26:51 success\n2021/09/16 16:26:52 failure\n2021/09/16 16:26:52 from: closed, to: open\n2021/09/16 16:26:53 err: circuit breaker is open\n2021/09/16 16:26:54 err: circuit breaker is open\n2021/09/16 16:26:55 err: circuit breaker is open\n......\n```\n\n## 参考\n\n- [Circuit Breaker Pattern](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589784(v=pandp.10)>)\n- [gobreaker](https://github.com/sony/gobreaker)\n","source":"_posts/golang/gobreaker.md","raw":"---\ntitle: 熔断器模式\ndate: 2021-09-16 16:21:28\ncategories: Golang\ntags:\n  - 微服务\n---\n\n熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。\n\n## 背景和问题\n\n在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。\n\n此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是**立即**让调用失败，只有在可能成功时才尝试调用服务。\n\n<!-- more -->\n\n{% note warning %}\n设置一个更短的超时可能有助于解决这个问题，但是超时不应该太短，这可能会让那些本来应该成功的请求也超时。\n{% endnote %}\n\n## 解决\n\n熔断器作为一个可能失败操作的代理，监控最近发生故障的数量，然后使用这些信息来决定是否允许操作继续，防止应用程序反复执行失败操作。\n\n熔断器本质上就是一个**状态机**，它具有以下状态：\n\n- **Closed：**程序可以正常发出请求，熔断器维护最近失败的次数，如果操作调用不成功，则熔断器增加此计数。如果在给定时间内，失败次数超过了指定的阈值，状态机将变为 **Open** 状态。此时，启动一个计时器，在一定时间后，状态机变为 **Half-Open** 状态。\n- **Open：**程序发出的请求会立即失败，并向程序返回异常。（相当于电闸跳闸了）\n- **Half-Open：**程序只能执行有限数量的请求操作，如果这些请求成功了（故障已经恢复），状态机变为 **Closed** 状态。如果请求失败了，状态机变为 **Open** 状态，并且重新启动计时器。\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161309094.png)\n\n## Golang 实现\n\n[![gobreaker](https://github-readme-stats.vercel.app/api/pin/?username=sony&repo=gobreaker&show_owner=true)](https://github.com/sony/gobreaker)\n\n### 使用\n\n我们可以通过 `Settings` 结构体配置熔断器：\n\n```go\ntype Settings struct {\n    Name          string\n    MaxRequests   uint32\n    Interval      time.Duration\n    Timeout       time.Duration\n    ReadyToTrip   func(counts Counts) bool\n    OnStateChange func(name string, from State, to State)\n}\n```\n\n- `MaxRequests`: **Half-Open** 状态下的最大请求次数，默认为 1\n- `Interval`: **Closed** 状态下清空计数器的周期，默认不清空\n- `Timeout`: **Open** 状态转 **Half-Open** 状态的时间，默认 60 秒\n- `ReadyToTrip`: 通过计数器的信息判断是否需要熔断，默认连续失败 5 次后熔断\n- `OnStateChange`: 状态变化时的回调\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"log\"\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/sony/gobreaker\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings{\n        ReadyToTrip: func(counts gobreaker.Counts) bool {\n            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n            // 失败率大于 60% 时熔断\n            return counts.Requests >= 3 && failureRatio >= 0.6\n        },\n        OnStateChange: func(_ string, from, to gobreaker.State) {\n            log.Printf(\"from: %v, to: %v\\n\", from, to)\n        },\n    })\n\n    for {\n        result, err := cb.Execute(func() (interface{}, error) {\n            // 模拟 70% 的失败率\n            if rand.Float64() < 0.7 {\n                return nil, errors.New(\"some error\")\n            }\n            return \"ok\", nil\n        })\n        log.Printf(\"result: %v, err: %v\\n\", result, err)\n        time.Sleep(time.Second)\n    }\n}\n```\n\n运行结果：\n\n```bash\n$ go run main.go\n2021/09/16 15:23:24 result: <nil>, err: some error\n2021/09/16 15:23:25 result: <nil>, err: some error\n2021/09/16 15:23:26 from: closed, to: open\n2021/09/16 15:23:26 result: <nil>, err: some error\n2021/09/16 15:23:27 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:28 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:29 result: <nil>, err: circuit breaker is open\n2021/09/16 15:23:30 result: <nil>, err: circuit breaker is open\n......\n```\n\n### Execute 流程\n\n简单过一遍 `Execute()` 的流程，详细代码可以看 [gobreader.go](https://github.com/sony/gobreaker/blob/master/gobreaker.go)，不到 400 行，实现的非常简洁。\n\n```go\nfunc (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {\n    // 增加计数，判断状态\n    generation, err := cb.beforeRequest()\n    if err != nil {\n        // 如果熔断器已经 Open，在这里就会直接返回 ErrOpenState\n        // Half-Open 状态下超过最大请求数则返回 ErrTooManyRequests\n        return nil, err\n    }\n\n    defer func() {\n        e := recover()\n        if e != nil {\n            cb.afterRequest(generation, false)\n            panic(e)\n        }\n    }()\n\n    // 执行真正的操作\n    result, err := req()\n\n    // 增加计数，达到阈值就熔断，err 非空表示失败\n    cb.afterRequest(generation, err == nil)\n    return result, err\n}\n```\n\n从上面的源码，我们可以看出，执行过程只是简单地通过 `err == nil` 判断成功，假设业务的逻辑很复杂，需要加入自定义的判断，可以用 `TwoStepCircuitBreaker`。\n\n### 两阶段熔断\n\n和普通熔断器的使用差不多，`Allow()` 方法只是调用了 `beforeRequest()`，然后返回回调函数 `done(success bool)` 和错误信息，通过回调函数我们能把操作成功与否告诉熔断器。\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/sony/gobreaker\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    cb := gobreaker.NewTwoStepCircuitBreaker(gobreaker.Settings{\n        ReadyToTrip: func(counts gobreaker.Counts) bool {\n            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n            return counts.Requests >= 3 && failureRatio >= 0.6\n        },\n        OnStateChange: func(_ string, from, to gobreaker.State) {\n            log.Printf(\"from: %v, to: %v\\n\", from, to)\n        },\n    })\n\n    for {\n        time.Sleep(time.Second)\n        done, err := cb.Allow()\n        if err != nil {\n            log.Printf(\"err: %v\\n\", err)\n            continue\n        }\n        success := true\n        if rand.Float64() < 0.7 {\n            log.Println(\"failure\")\n            success = false\n        } else {\n            log.Println(\"success\")\n        }\n        done(success)\n    }\n}\n```\n\n运行结果：\n\n```bash\n$ go run main.go\n2021/09/16 16:26:49 failure\n2021/09/16 16:26:50 failure\n2021/09/16 16:26:51 success\n2021/09/16 16:26:52 failure\n2021/09/16 16:26:52 from: closed, to: open\n2021/09/16 16:26:53 err: circuit breaker is open\n2021/09/16 16:26:54 err: circuit breaker is open\n2021/09/16 16:26:55 err: circuit breaker is open\n......\n```\n\n## 参考\n\n- [Circuit Breaker Pattern](<https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589784(v=pandp.10)>)\n- [gobreaker](https://github.com/sony/gobreaker)\n","slug":"golang/gobreaker","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdq0007xeoad2nvftzg","content":"<p>熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。</p>\n<h2 id=\"背景和问题\"><a href=\"#背景和问题\" class=\"headerlink\" title=\"背景和问题\"></a>背景和问题</h2><p>在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。</p>\n<p>此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是<strong>立即</strong>让调用失败，只有在可能成功时才尝试调用服务。</p>\n<span id=\"more\"></span>\n\n<div class=\"note warning\"><p>设置一个更短的超时可能有助于解决这个问题，但是超时不应该太短，这可能会让那些本来应该成功的请求也超时。</p>\n</div>\n\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>熔断器作为一个可能失败操作的代理，监控最近发生故障的数量，然后使用这些信息来决定是否允许操作继续，防止应用程序反复执行失败操作。</p>\n<p>熔断器本质上就是一个<strong>状态机</strong>，它具有以下状态：</p>\n<ul>\n<li><strong>Closed：</strong>程序可以正常发出请求，熔断器维护最近失败的次数，如果操作调用不成功，则熔断器增加此计数。如果在给定时间内，失败次数超过了指定的阈值，状态机将变为 <strong>Open</strong> 状态。此时，启动一个计时器，在一定时间后，状态机变为 <strong>Half-Open</strong> 状态。</li>\n<li><strong>Open：</strong>程序发出的请求会立即失败，并向程序返回异常。（相当于电闸跳闸了）</li>\n<li><strong>Half-Open：</strong>程序只能执行有限数量的请求操作，如果这些请求成功了（故障已经恢复），状态机变为 <strong>Closed</strong> 状态。如果请求失败了，状态机变为 <strong>Open</strong> 状态，并且重新启动计时器。</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161309094.png\" loading=\"lazy\"></p>\n<h2 id=\"Golang-实现\"><a href=\"#Golang-实现\" class=\"headerlink\" title=\"Golang 实现\"></a>Golang 实现</h2><p><a href=\"https://github.com/sony/gobreaker\"><img data-src=\"https://github-readme-stats.vercel.app/api/pin/?username=sony&repo=gobreaker&show_owner=true\" alt=\"gobreaker\" loading=\"lazy\"></a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>我们可以通过 <code>Settings</code> 结构体配置熔断器：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Settings <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name          <span class=\"type\">string</span></span><br><span class=\"line\">    MaxRequests   <span class=\"type\">uint32</span></span><br><span class=\"line\">    Interval      time.Duration</span><br><span class=\"line\">    Timeout       time.Duration</span><br><span class=\"line\">    ReadyToTrip   <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts Counts)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\">    OnStateChange <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(name <span class=\"type\">string</span>, from State, to State)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MaxRequests</code>: <strong>Half-Open</strong> 状态下的最大请求次数，默认为 1</li>\n<li><code>Interval</code>: <strong>Closed</strong> 状态下清空计数器的周期，默认不清空</li>\n<li><code>Timeout</code>: <strong>Open</strong> 状态转 <strong>Half-Open</strong> 状态的时间，默认 60 秒</li>\n<li><code>ReadyToTrip</code>: 通过计数器的信息判断是否需要熔断，默认连续失败 5 次后熔断</li>\n<li><code>OnStateChange</code>: 状态变化时的回调</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;</span><br><span class=\"line\">        ReadyToTrip: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts gobreaker.Counts)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            failureRatio := <span class=\"type\">float64</span>(counts.TotalFailures) / <span class=\"type\">float64</span>(counts.Requests)</span><br><span class=\"line\">            <span class=\"comment\">// 失败率大于 60% 时熔断</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> counts.Requests &gt;= <span class=\"number\">3</span> &amp;&amp; failureRatio &gt;= <span class=\"number\">0.6</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        OnStateChange: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;from: %v, to: %v\\n&quot;</span>, from, to)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        result, err := cb.Execute(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟 70% 的失败率</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rand.Float64() &lt; <span class=\"number\">0.7</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.New(<span class=\"string\">&quot;some error&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;result: %v, err: %v\\n&quot;</span>, result, err)</span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run main.go</span><br><span class=\"line\">2021/09/16 15:23:24 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:25 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:26 from: closed, to: open</span><br><span class=\"line\">2021/09/16 15:23:26 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:27 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:28 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:29 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:30 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Execute-流程\"><a href=\"#Execute-流程\" class=\"headerlink\" title=\"Execute 流程\"></a>Execute 流程</h3><p>简单过一遍 <code>Execute()</code> 的流程，详细代码可以看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2VyL2Jsb2IvbWFzdGVyL2dvYnJlYWtlci5nbw==\">gobreader.go<i class=\"fa fa-external-link-alt\"></i></span>，不到 400 行，实现的非常简洁。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cb *CircuitBreaker)</span></span> Execute(req <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加计数，判断状态</span></span><br><span class=\"line\">    generation, err := cb.beforeRequest()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果熔断器已经 Open，在这里就会直接返回 ErrOpenState</span></span><br><span class=\"line\">        <span class=\"comment\">// Half-Open 状态下超过最大请求数则返回 ErrTooManyRequests</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        e := <span class=\"built_in\">recover</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            cb.afterRequest(generation, <span class=\"literal\">false</span>)</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行真正的操作</span></span><br><span class=\"line\">    result, err := req()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加计数，达到阈值就熔断，err 非空表示失败</span></span><br><span class=\"line\">    cb.afterRequest(generation, err == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的源码，我们可以看出，执行过程只是简单地通过 <code>err == nil</code> 判断成功，假设业务的逻辑很复杂，需要加入自定义的判断，可以用 <code>TwoStepCircuitBreaker</code>。</p>\n<h3 id=\"两阶段熔断\"><a href=\"#两阶段熔断\" class=\"headerlink\" title=\"两阶段熔断\"></a>两阶段熔断</h3><p>和普通熔断器的使用差不多，<code>Allow()</code> 方法只是调用了 <code>beforeRequest()</code>，然后返回回调函数 <code>done(success bool)</code> 和错误信息，通过回调函数我们能把操作成功与否告诉熔断器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">    cb := gobreaker.NewTwoStepCircuitBreaker(gobreaker.Settings&#123;</span><br><span class=\"line\">        ReadyToTrip: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts gobreaker.Counts)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            failureRatio := <span class=\"type\">float64</span>(counts.TotalFailures) / <span class=\"type\">float64</span>(counts.Requests)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> counts.Requests &gt;= <span class=\"number\">3</span> &amp;&amp; failureRatio &gt;= <span class=\"number\">0.6</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        OnStateChange: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;from: %v, to: %v\\n&quot;</span>, from, to)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">        done, err := cb.Allow()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;err: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        success := <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> rand.Float64() &lt; <span class=\"number\">0.7</span> &#123;</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;failure&quot;</span>)</span><br><span class=\"line\">            success = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;success&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        done(success)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run main.go</span><br><span class=\"line\">2021/09/16 16:26:49 failure</span><br><span class=\"line\">2021/09/16 16:26:50 failure</span><br><span class=\"line\">2021/09/16 16:26:51 success</span><br><span class=\"line\">2021/09/16 16:26:52 failure</span><br><span class=\"line\">2021/09/16 16:26:52 from: closed, to: open</span><br><span class=\"line\">2021/09/16 16:26:53 err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 16:26:54 err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 16:26:55 err: circuit breaker is open</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvbXNwLW4tcC9kbjU4OTc4NCh2PXBhbmRwLjEwKQ==\">Circuit Breaker Pattern<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2Vy\">gobreaker<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n","site":{"data":{}},"length":4259,"excerpt":"<p>熔断器模式提高了系统从故障恢复时的稳定性，最小化了故障对性能的影响。</p>\n<h2 id=\"背景和问题\"><a href=\"#背景和问题\" class=\"headerlink\" title=\"背景和问题\"></a>背景和问题</h2><p>在复杂的网络环境下，执行远程调用可能会遇到各种超时或故障，虽然大部分情况这些问题能在短时间内自动恢复，只需要重试几次就能调用成功。但是，有些问题需要很长时间来恢复时，不断重试显然不是一个很好的解决方案。相反，应用程序应该迅速接受这次操作失败，并进行相应的错误处理。</p>\n<p>此外，如果一个服务非常繁忙，系统的一个部分的故障可能会导致级联故障。例如，服务调用方设置了调用的超时时间，如果服务在这段时间内没有返回响应，调用方直接用错误消息进行回复。这种策略可能会导致许多同一操作的并发请求被阻塞，直到超时。这些被阻塞的请求会占用着大量的系统资源（内存，线程，数据库连接等），这些资源耗尽，导致系统中需要使用相同资源的其他服务出现故障。在这种情况下，最好是<strong>立即</strong>让调用失败，只有在可能成功时才尝试调用服务。</p>","more":"<div class=\"note warning\"><p>设置一个更短的超时可能有助于解决这个问题，但是超时不应该太短，这可能会让那些本来应该成功的请求也超时。</p>\n</div>\n\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>熔断器作为一个可能失败操作的代理，监控最近发生故障的数量，然后使用这些信息来决定是否允许操作继续，防止应用程序反复执行失败操作。</p>\n<p>熔断器本质上就是一个<strong>状态机</strong>，它具有以下状态：</p>\n<ul>\n<li><strong>Closed：</strong>程序可以正常发出请求，熔断器维护最近失败的次数，如果操作调用不成功，则熔断器增加此计数。如果在给定时间内，失败次数超过了指定的阈值，状态机将变为 <strong>Open</strong> 状态。此时，启动一个计时器，在一定时间后，状态机变为 <strong>Half-Open</strong> 状态。</li>\n<li><strong>Open：</strong>程序发出的请求会立即失败，并向程序返回异常。（相当于电闸跳闸了）</li>\n<li><strong>Half-Open：</strong>程序只能执行有限数量的请求操作，如果这些请求成功了（故障已经恢复），状态机变为 <strong>Closed</strong> 状态。如果请求失败了，状态机变为 <strong>Open</strong> 状态，并且重新启动计时器。</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161309094.png\" loading=\"lazy\"></p>\n<h2 id=\"Golang-实现\"><a href=\"#Golang-实现\" class=\"headerlink\" title=\"Golang 实现\"></a>Golang 实现</h2><p><a href=\"https://github.com/sony/gobreaker\"><img data-src=\"https://github-readme-stats.vercel.app/api/pin/?username=sony&repo=gobreaker&show_owner=true\" alt=\"gobreaker\" loading=\"lazy\"></a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>我们可以通过 <code>Settings</code> 结构体配置熔断器：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Settings <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name          <span class=\"type\">string</span></span><br><span class=\"line\">    MaxRequests   <span class=\"type\">uint32</span></span><br><span class=\"line\">    Interval      time.Duration</span><br><span class=\"line\">    Timeout       time.Duration</span><br><span class=\"line\">    ReadyToTrip   <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts Counts)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\">    OnStateChange <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(name <span class=\"type\">string</span>, from State, to State)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MaxRequests</code>: <strong>Half-Open</strong> 状态下的最大请求次数，默认为 1</li>\n<li><code>Interval</code>: <strong>Closed</strong> 状态下清空计数器的周期，默认不清空</li>\n<li><code>Timeout</code>: <strong>Open</strong> 状态转 <strong>Half-Open</strong> 状态的时间，默认 60 秒</li>\n<li><code>ReadyToTrip</code>: 通过计数器的信息判断是否需要熔断，默认连续失败 5 次后熔断</li>\n<li><code>OnStateChange</code>: 状态变化时的回调</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;</span><br><span class=\"line\">        ReadyToTrip: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts gobreaker.Counts)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            failureRatio := <span class=\"type\">float64</span>(counts.TotalFailures) / <span class=\"type\">float64</span>(counts.Requests)</span><br><span class=\"line\">            <span class=\"comment\">// 失败率大于 60% 时熔断</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> counts.Requests &gt;= <span class=\"number\">3</span> &amp;&amp; failureRatio &gt;= <span class=\"number\">0.6</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        OnStateChange: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;from: %v, to: %v\\n&quot;</span>, from, to)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        result, err := cb.Execute(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟 70% 的失败率</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rand.Float64() &lt; <span class=\"number\">0.7</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.New(<span class=\"string\">&quot;some error&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;result: %v, err: %v\\n&quot;</span>, result, err)</span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run main.go</span><br><span class=\"line\">2021/09/16 15:23:24 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:25 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:26 from: closed, to: open</span><br><span class=\"line\">2021/09/16 15:23:26 result: &lt;nil&gt;, err: some error</span><br><span class=\"line\">2021/09/16 15:23:27 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:28 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:29 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 15:23:30 result: &lt;nil&gt;, err: circuit breaker is open</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Execute-流程\"><a href=\"#Execute-流程\" class=\"headerlink\" title=\"Execute 流程\"></a>Execute 流程</h3><p>简单过一遍 <code>Execute()</code> 的流程，详细代码可以看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2VyL2Jsb2IvbWFzdGVyL2dvYnJlYWtlci5nbw==\">gobreader.go<i class=\"fa fa-external-link-alt\"></i></span>，不到 400 行，实现的非常简洁。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cb *CircuitBreaker)</span></span> Execute(req <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>)) (<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增加计数，判断状态</span></span><br><span class=\"line\">    generation, err := cb.beforeRequest()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果熔断器已经 Open，在这里就会直接返回 ErrOpenState</span></span><br><span class=\"line\">        <span class=\"comment\">// Half-Open 状态下超过最大请求数则返回 ErrTooManyRequests</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        e := <span class=\"built_in\">recover</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            cb.afterRequest(generation, <span class=\"literal\">false</span>)</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行真正的操作</span></span><br><span class=\"line\">    result, err := req()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加计数，达到阈值就熔断，err 非空表示失败</span></span><br><span class=\"line\">    cb.afterRequest(generation, err == <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的源码，我们可以看出，执行过程只是简单地通过 <code>err == nil</code> 判断成功，假设业务的逻辑很复杂，需要加入自定义的判断，可以用 <code>TwoStepCircuitBreaker</code>。</p>\n<h3 id=\"两阶段熔断\"><a href=\"#两阶段熔断\" class=\"headerlink\" title=\"两阶段熔断\"></a>两阶段熔断</h3><p>和普通熔断器的使用差不多，<code>Allow()</code> 方法只是调用了 <code>beforeRequest()</code>，然后返回回调函数 <code>done(success bool)</code> 和错误信息，通过回调函数我们能把操作成功与否告诉熔断器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/sony/gobreaker&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">    cb := gobreaker.NewTwoStepCircuitBreaker(gobreaker.Settings&#123;</span><br><span class=\"line\">        ReadyToTrip: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(counts gobreaker.Counts)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            failureRatio := <span class=\"type\">float64</span>(counts.TotalFailures) / <span class=\"type\">float64</span>(counts.Requests)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> counts.Requests &gt;= <span class=\"number\">3</span> &amp;&amp; failureRatio &gt;= <span class=\"number\">0.6</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        OnStateChange: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>, from, to gobreaker.State)</span></span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;from: %v, to: %v\\n&quot;</span>, from, to)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        time.Sleep(time.Second)</span><br><span class=\"line\">        done, err := cb.Allow()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;err: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        success := <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> rand.Float64() &lt; <span class=\"number\">0.7</span> &#123;</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;failure&quot;</span>)</span><br><span class=\"line\">            success = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.Println(<span class=\"string\">&quot;success&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        done(success)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run main.go</span><br><span class=\"line\">2021/09/16 16:26:49 failure</span><br><span class=\"line\">2021/09/16 16:26:50 failure</span><br><span class=\"line\">2021/09/16 16:26:51 success</span><br><span class=\"line\">2021/09/16 16:26:52 failure</span><br><span class=\"line\">2021/09/16 16:26:52 from: closed, to: open</span><br><span class=\"line\">2021/09/16 16:26:53 err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 16:26:54 err: circuit breaker is open</span><br><span class=\"line\">2021/09/16 16:26:55 err: circuit breaker is open</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvbXNwLW4tcC9kbjU4OTc4NCh2PXBhbmRwLjEwKQ==\">Circuit Breaker Pattern<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NvbnkvZ29icmVha2Vy\">gobreaker<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>"},{"title":"无锁队列的简单实现","date":"2021-06-25T08:16:59.000Z","_content":"\n谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 [Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms](https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf)，Java 中 `ConcurrentLinkedQueue` 也是基于该论文的算法实现。\n\n<!-- more -->\n\n## 伪代码\n\n论文中 lock-free queue 算法的伪代码：\n\n正如论文的题目描述的，它非常简单，代码量很少。主要思路就是使用 [CAS](https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2) 操作队列的头指针和尾指针，以实现线程安全。\n\n```text\nstructure pointer_t {ptr: pointer to node_t, count: unsigned integer}\nstructure node_t {value: data type, next: pointer_t}\nstructure queue_t {Head: pointer_t, Tail: pointer_t}\n\ninitialize(Q: pointer to queue_t)\n   node = new_node()\t\t// Allocate a free node\n   node->next.ptr = NULL\t// Make it the only node in the linked list\n   Q->Head.ptr = Q->Tail.ptr = node\t// Both Head and Tail point to it\n\nenqueue(Q: pointer to queue_t, value: data type)\n E1:   node = new_node()\t// Allocate a new node from the free list\n E2:   node->value = value\t// Copy enqueued value into node\n E3:   node->next.ptr = NULL\t// Set next pointer of node to NULL\n E4:   loop\t\t\t// Keep trying until Enqueue is done\n E5:      tail = Q->Tail\t// Read Tail.ptr and Tail.count together\n E6:      next = tail.ptr->next\t// Read next ptr and count fields together\n E7:      if tail == Q->Tail\t// Are tail and next consistent?\n             // Was Tail pointing to the last node?\n E8:         if next.ptr == NULL\n                // Try to link node at the end of the linked list\n E9:            if CAS(&tail.ptr->next, next, <node, next.count+1>)\nE10:               break\t// Enqueue is done.  Exit loop\nE11:            endif\nE12:         else\t\t// Tail was not pointing to the last node\n                // Try to swing Tail to the next node\nE13:            CAS(&Q->Tail, tail, <next.ptr, tail.count+1>)\nE14:         endif\nE15:      endif\nE16:   endloop\n       // Enqueue is done.  Try to swing Tail to the inserted node\nE17:   CAS(&Q->Tail, tail, <node, tail.count+1>)\n\ndequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean\n D1:   loop\t\t\t     // Keep trying until Dequeue is done\n D2:      head = Q->Head\t     // Read Head\n D3:      tail = Q->Tail\t     // Read Tail\n D4:      next = head.ptr->next    // Read Head.ptr->next\n D5:      if head == Q->Head\t     // Are head, tail, and next consistent?\n D6:         if head.ptr == tail.ptr // Is queue empty or Tail falling behind?\n D7:            if next.ptr == NULL  // Is queue empty?\n D8:               return FALSE      // Queue is empty, couldn't dequeue\n D9:            endif\n                // Tail is falling behind.  Try to advance it\nD10:            CAS(&Q->Tail, tail, <next.ptr, tail.count+1>)\nD11:         else\t\t     // No need to deal with Tail\n                // Read value before CAS\n                // Otherwise, another dequeue might free the next node\nD12:            *pvalue = next.ptr->value\n                // Try to swing Head to the next node\nD13:            if CAS(&Q->Head, head, <next.ptr, head.count+1>)\nD14:               break             // Dequeue is done.  Exit loop\nD15:            endif\nD16:         endif\nD17:      endif\nD18:   endloop\nD19:   free(head.ptr)\t\t     // It is safe now to free the old node\nD20:   return TRUE                   // Queue was not empty, dequeue succeeded\n```\n\n## 实现\n\n简单起见，不考虑 [ABA](https://en.wikipedia.org/wiki/ABA_problem) 问题，所以没有实现带版本号的 CAS\n\n```go\nimport (\n    \"sync/atomic\"\n    \"unsafe\"\n)\n\ntype lockFreeQueue struct {\n    head unsafe.Pointer\n    tail unsafe.Pointer\n    len  int32\n}\n\ntype node struct {\n    value interface{}\n    next  unsafe.Pointer\n}\n\nfunc NewLockFreeQueue() *lockFreeQueue {\n    n := unsafe.Pointer(&node{})\n    return &lockFreeQueue{head: n, tail: n}\n}\n\nfunc (q *lockFreeQueue) Enqueue(v interface{}) {\n    n := &node{value: v}\n    for {\n        tail := load(&q.tail)\n        next := load(&tail.next)\n        if tail == load(&q.tail) {\n            if next == nil {\n                if cas(&tail.next, next, n) {\n                    cas(&q.tail, tail, n)\n                    atomic.AddInt32(&q.len, 1)\n                    return\n                }\n            } else {\n                cas(&q.tail, tail, next)\n            }\n        }\n    }\n}\n\nfunc (q *lockFreeQueue) Dequeue() interface{} {\n    for {\n        head := load(&q.head)\n        tail := load(&q.tail)\n        next := load(&head.next)\n        if head == load(&q.head) {\n            if head == tail {\n                if next == nil {\n                    return nil\n                }\n                cas(&q.tail, tail, next)\n            } else {\n                v := next.value\n                if cas(&q.head, head, next) {\n                    atomic.AddInt32(&q.len, -1)\n                    return v\n                }\n            }\n        }\n    }\n}\n\nfunc (q *lockFreeQueue) Empty() bool {\n    return atomic.LoadInt32(&q.len) != 0\n}\n\nfunc load(p *unsafe.Pointer) *node {\n    return (*node)(atomic.LoadPointer(p))\n}\n\nfunc cas(p *unsafe.Pointer, old, new *node) bool {\n    return atomic.CompareAndSwapPointer(p,\n        unsafe.Pointer(old), unsafe.Pointer(new))\n}\n```\n","source":"_posts/golang/lock-free-queue.md","raw":"---\ntitle: 无锁队列的简单实现\ndate: 2021-06-25 16:16:59\ncategories: Golang\ntags:\n  - 并发\n  - CAS\n  - unsafe\n---\n\n谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 [Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms](https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf)，Java 中 `ConcurrentLinkedQueue` 也是基于该论文的算法实现。\n\n<!-- more -->\n\n## 伪代码\n\n论文中 lock-free queue 算法的伪代码：\n\n正如论文的题目描述的，它非常简单，代码量很少。主要思路就是使用 [CAS](https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2) 操作队列的头指针和尾指针，以实现线程安全。\n\n```text\nstructure pointer_t {ptr: pointer to node_t, count: unsigned integer}\nstructure node_t {value: data type, next: pointer_t}\nstructure queue_t {Head: pointer_t, Tail: pointer_t}\n\ninitialize(Q: pointer to queue_t)\n   node = new_node()\t\t// Allocate a free node\n   node->next.ptr = NULL\t// Make it the only node in the linked list\n   Q->Head.ptr = Q->Tail.ptr = node\t// Both Head and Tail point to it\n\nenqueue(Q: pointer to queue_t, value: data type)\n E1:   node = new_node()\t// Allocate a new node from the free list\n E2:   node->value = value\t// Copy enqueued value into node\n E3:   node->next.ptr = NULL\t// Set next pointer of node to NULL\n E4:   loop\t\t\t// Keep trying until Enqueue is done\n E5:      tail = Q->Tail\t// Read Tail.ptr and Tail.count together\n E6:      next = tail.ptr->next\t// Read next ptr and count fields together\n E7:      if tail == Q->Tail\t// Are tail and next consistent?\n             // Was Tail pointing to the last node?\n E8:         if next.ptr == NULL\n                // Try to link node at the end of the linked list\n E9:            if CAS(&tail.ptr->next, next, <node, next.count+1>)\nE10:               break\t// Enqueue is done.  Exit loop\nE11:            endif\nE12:         else\t\t// Tail was not pointing to the last node\n                // Try to swing Tail to the next node\nE13:            CAS(&Q->Tail, tail, <next.ptr, tail.count+1>)\nE14:         endif\nE15:      endif\nE16:   endloop\n       // Enqueue is done.  Try to swing Tail to the inserted node\nE17:   CAS(&Q->Tail, tail, <node, tail.count+1>)\n\ndequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean\n D1:   loop\t\t\t     // Keep trying until Dequeue is done\n D2:      head = Q->Head\t     // Read Head\n D3:      tail = Q->Tail\t     // Read Tail\n D4:      next = head.ptr->next    // Read Head.ptr->next\n D5:      if head == Q->Head\t     // Are head, tail, and next consistent?\n D6:         if head.ptr == tail.ptr // Is queue empty or Tail falling behind?\n D7:            if next.ptr == NULL  // Is queue empty?\n D8:               return FALSE      // Queue is empty, couldn't dequeue\n D9:            endif\n                // Tail is falling behind.  Try to advance it\nD10:            CAS(&Q->Tail, tail, <next.ptr, tail.count+1>)\nD11:         else\t\t     // No need to deal with Tail\n                // Read value before CAS\n                // Otherwise, another dequeue might free the next node\nD12:            *pvalue = next.ptr->value\n                // Try to swing Head to the next node\nD13:            if CAS(&Q->Head, head, <next.ptr, head.count+1>)\nD14:               break             // Dequeue is done.  Exit loop\nD15:            endif\nD16:         endif\nD17:      endif\nD18:   endloop\nD19:   free(head.ptr)\t\t     // It is safe now to free the old node\nD20:   return TRUE                   // Queue was not empty, dequeue succeeded\n```\n\n## 实现\n\n简单起见，不考虑 [ABA](https://en.wikipedia.org/wiki/ABA_problem) 问题，所以没有实现带版本号的 CAS\n\n```go\nimport (\n    \"sync/atomic\"\n    \"unsafe\"\n)\n\ntype lockFreeQueue struct {\n    head unsafe.Pointer\n    tail unsafe.Pointer\n    len  int32\n}\n\ntype node struct {\n    value interface{}\n    next  unsafe.Pointer\n}\n\nfunc NewLockFreeQueue() *lockFreeQueue {\n    n := unsafe.Pointer(&node{})\n    return &lockFreeQueue{head: n, tail: n}\n}\n\nfunc (q *lockFreeQueue) Enqueue(v interface{}) {\n    n := &node{value: v}\n    for {\n        tail := load(&q.tail)\n        next := load(&tail.next)\n        if tail == load(&q.tail) {\n            if next == nil {\n                if cas(&tail.next, next, n) {\n                    cas(&q.tail, tail, n)\n                    atomic.AddInt32(&q.len, 1)\n                    return\n                }\n            } else {\n                cas(&q.tail, tail, next)\n            }\n        }\n    }\n}\n\nfunc (q *lockFreeQueue) Dequeue() interface{} {\n    for {\n        head := load(&q.head)\n        tail := load(&q.tail)\n        next := load(&head.next)\n        if head == load(&q.head) {\n            if head == tail {\n                if next == nil {\n                    return nil\n                }\n                cas(&q.tail, tail, next)\n            } else {\n                v := next.value\n                if cas(&q.head, head, next) {\n                    atomic.AddInt32(&q.len, -1)\n                    return v\n                }\n            }\n        }\n    }\n}\n\nfunc (q *lockFreeQueue) Empty() bool {\n    return atomic.LoadInt32(&q.len) != 0\n}\n\nfunc load(p *unsafe.Pointer) *node {\n    return (*node)(atomic.LoadPointer(p))\n}\n\nfunc cas(p *unsafe.Pointer, old, new *node) bool {\n    return atomic.CompareAndSwapPointer(p,\n        unsafe.Pointer(old), unsafe.Pointer(new))\n}\n```\n","slug":"golang/lock-free-queue","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdr0008xeoae3ca07bd","content":"<p>谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS91L3Njb3R0L3BhcGVycy8xOTk2X1BPRENfcXVldWVzLnBkZg==\">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms<i class=\"fa fa-external-link-alt\"></i></span>，Java 中 <code>ConcurrentLinkedQueue</code> 也是基于该论文的算法实现。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p>论文中 lock-free queue 算法的伪代码：</p>\n<p>正如论文的题目描述的，它非常简单，代码量很少。主要思路就是使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJTk0JUU4JUJFJTgzJUU1JUI5JUI2JUU0JUJBJUE0JUU2JThEJUEy\">CAS<i class=\"fa fa-external-link-alt\"></i></span> 操作队列的头指针和尾指针，以实现线程安全。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">structure pointer_t &#123;ptr: pointer to node_t, count: unsigned integer&#125;</span><br><span class=\"line\">structure node_t &#123;value: data type, next: pointer_t&#125;</span><br><span class=\"line\">structure queue_t &#123;Head: pointer_t, Tail: pointer_t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initialize(Q: pointer to queue_t)</span><br><span class=\"line\">   node = new_node()        // Allocate a free node</span><br><span class=\"line\">   node-&gt;next.ptr = NULL    // Make it the only node in the linked list</span><br><span class=\"line\">   Q-&gt;Head.ptr = Q-&gt;Tail.ptr = node    // Both Head and Tail point to it</span><br><span class=\"line\"></span><br><span class=\"line\">enqueue(Q: pointer to queue_t, value: data type)</span><br><span class=\"line\"> E1:   node = new_node()    // Allocate a new node from the free list</span><br><span class=\"line\"> E2:   node-&gt;value = value    // Copy enqueued value into node</span><br><span class=\"line\"> E3:   node-&gt;next.ptr = NULL    // Set next pointer of node to NULL</span><br><span class=\"line\"> E4:   loop            // Keep trying until Enqueue is done</span><br><span class=\"line\"> E5:      tail = Q-&gt;Tail    // Read Tail.ptr and Tail.count together</span><br><span class=\"line\"> E6:      next = tail.ptr-&gt;next    // Read next ptr and count fields together</span><br><span class=\"line\"> E7:      if tail == Q-&gt;Tail    // Are tail and next consistent?</span><br><span class=\"line\">             // Was Tail pointing to the last node?</span><br><span class=\"line\"> E8:         if next.ptr == NULL</span><br><span class=\"line\">                // Try to link node at the end of the linked list</span><br><span class=\"line\"> E9:            if CAS(&amp;tail.ptr-&gt;next, next, &lt;node, next.count+1&gt;)</span><br><span class=\"line\">E10:               break    // Enqueue is done.  Exit loop</span><br><span class=\"line\">E11:            endif</span><br><span class=\"line\">E12:         else        // Tail was not pointing to the last node</span><br><span class=\"line\">                // Try to swing Tail to the next node</span><br><span class=\"line\">E13:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class=\"line\">E14:         endif</span><br><span class=\"line\">E15:      endif</span><br><span class=\"line\">E16:   endloop</span><br><span class=\"line\">       // Enqueue is done.  Try to swing Tail to the inserted node</span><br><span class=\"line\">E17:   CAS(&amp;Q-&gt;Tail, tail, &lt;node, tail.count+1&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">dequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean</span><br><span class=\"line\"> D1:   loop                 // Keep trying until Dequeue is done</span><br><span class=\"line\"> D2:      head = Q-&gt;Head         // Read Head</span><br><span class=\"line\"> D3:      tail = Q-&gt;Tail         // Read Tail</span><br><span class=\"line\"> D4:      next = head.ptr-&gt;next    // Read Head.ptr-&gt;next</span><br><span class=\"line\"> D5:      if head == Q-&gt;Head         // Are head, tail, and next consistent?</span><br><span class=\"line\"> D6:         if head.ptr == tail.ptr // Is queue empty or Tail falling behind?</span><br><span class=\"line\"> D7:            if next.ptr == NULL  // Is queue empty?</span><br><span class=\"line\"> D8:               return FALSE      // Queue is empty, couldn&#x27;t dequeue</span><br><span class=\"line\"> D9:            endif</span><br><span class=\"line\">                // Tail is falling behind.  Try to advance it</span><br><span class=\"line\">D10:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class=\"line\">D11:         else             // No need to deal with Tail</span><br><span class=\"line\">                // Read value before CAS</span><br><span class=\"line\">                // Otherwise, another dequeue might free the next node</span><br><span class=\"line\">D12:            *pvalue = next.ptr-&gt;value</span><br><span class=\"line\">                // Try to swing Head to the next node</span><br><span class=\"line\">D13:            if CAS(&amp;Q-&gt;Head, head, &lt;next.ptr, head.count+1&gt;)</span><br><span class=\"line\">D14:               break             // Dequeue is done.  Exit loop</span><br><span class=\"line\">D15:            endif</span><br><span class=\"line\">D16:         endif</span><br><span class=\"line\">D17:      endif</span><br><span class=\"line\">D18:   endloop</span><br><span class=\"line\">D19:   free(head.ptr)             // It is safe now to free the old node</span><br><span class=\"line\">D20:   return TRUE                   // Queue was not empty, dequeue succeeded</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>简单起见，不考虑 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQUJBX3Byb2JsZW0=\">ABA<i class=\"fa fa-external-link-alt\"></i></span> 问题，所以没有实现带版本号的 CAS</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;sync/atomic&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;unsafe&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> lockFreeQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    head unsafe.Pointer</span><br><span class=\"line\">    tail unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span>  <span class=\"type\">int32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    next  unsafe.Pointer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLockFreeQueue</span><span class=\"params\">()</span></span> *lockFreeQueue &#123;</span><br><span class=\"line\">    n := unsafe.Pointer(&amp;node&#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;lockFreeQueue&#123;head: n, tail: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Enqueue(v <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">    n := &amp;node&#123;value: v&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tail := load(&amp;q.tail)</span><br><span class=\"line\">        next := load(&amp;tail.next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tail == load(&amp;q.tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cas(&amp;tail.next, next, n) &#123;</span><br><span class=\"line\">                    cas(&amp;q.tail, tail, n)</span><br><span class=\"line\">                    atomic.AddInt32(&amp;q.<span class=\"built_in\">len</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cas(&amp;q.tail, tail, next)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Dequeue() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        head := load(&amp;q.head)</span><br><span class=\"line\">        tail := load(&amp;q.tail)</span><br><span class=\"line\">        next := load(&amp;head.next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head == load(&amp;q.head) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head == tail &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cas(&amp;q.tail, tail, next)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                v := next.value</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cas(&amp;q.head, head, next) &#123;</span><br><span class=\"line\">                    atomic.AddInt32(&amp;q.<span class=\"built_in\">len</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atomic.LoadInt32(&amp;q.<span class=\"built_in\">len</span>) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(p *unsafe.Pointer)</span></span> *node &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*node)(atomic.LoadPointer(p))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cas</span><span class=\"params\">(p *unsafe.Pointer, old, <span class=\"built_in\">new</span> *node)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atomic.CompareAndSwapPointer(p,</span><br><span class=\"line\">        unsafe.Pointer(old), unsafe.Pointer(<span class=\"built_in\">new</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":3712,"excerpt":"<p>谈到无锁队列，就不得不提 Michael 和 Scott 在 1996 年发表的论文 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS91L3Njb3R0L3BhcGVycy8xOTk2X1BPRENfcXVldWVzLnBkZg==\">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms<i class=\"fa fa-external-link-alt\"></i></span>，Java 中 <code>ConcurrentLinkedQueue</code> 也是基于该论文的算法实现。</p>","more":"<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p>论文中 lock-free queue 算法的伪代码：</p>\n<p>正如论文的题目描述的，它非常简单，代码量很少。主要思路就是使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJTk0JUU4JUJFJTgzJUU1JUI5JUI2JUU0JUJBJUE0JUU2JThEJUEy\">CAS<i class=\"fa fa-external-link-alt\"></i></span> 操作队列的头指针和尾指针，以实现线程安全。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">structure pointer_t &#123;ptr: pointer to node_t, count: unsigned integer&#125;</span><br><span class=\"line\">structure node_t &#123;value: data type, next: pointer_t&#125;</span><br><span class=\"line\">structure queue_t &#123;Head: pointer_t, Tail: pointer_t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initialize(Q: pointer to queue_t)</span><br><span class=\"line\">   node = new_node()        // Allocate a free node</span><br><span class=\"line\">   node-&gt;next.ptr = NULL    // Make it the only node in the linked list</span><br><span class=\"line\">   Q-&gt;Head.ptr = Q-&gt;Tail.ptr = node    // Both Head and Tail point to it</span><br><span class=\"line\"></span><br><span class=\"line\">enqueue(Q: pointer to queue_t, value: data type)</span><br><span class=\"line\"> E1:   node = new_node()    // Allocate a new node from the free list</span><br><span class=\"line\"> E2:   node-&gt;value = value    // Copy enqueued value into node</span><br><span class=\"line\"> E3:   node-&gt;next.ptr = NULL    // Set next pointer of node to NULL</span><br><span class=\"line\"> E4:   loop            // Keep trying until Enqueue is done</span><br><span class=\"line\"> E5:      tail = Q-&gt;Tail    // Read Tail.ptr and Tail.count together</span><br><span class=\"line\"> E6:      next = tail.ptr-&gt;next    // Read next ptr and count fields together</span><br><span class=\"line\"> E7:      if tail == Q-&gt;Tail    // Are tail and next consistent?</span><br><span class=\"line\">             // Was Tail pointing to the last node?</span><br><span class=\"line\"> E8:         if next.ptr == NULL</span><br><span class=\"line\">                // Try to link node at the end of the linked list</span><br><span class=\"line\"> E9:            if CAS(&amp;tail.ptr-&gt;next, next, &lt;node, next.count+1&gt;)</span><br><span class=\"line\">E10:               break    // Enqueue is done.  Exit loop</span><br><span class=\"line\">E11:            endif</span><br><span class=\"line\">E12:         else        // Tail was not pointing to the last node</span><br><span class=\"line\">                // Try to swing Tail to the next node</span><br><span class=\"line\">E13:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class=\"line\">E14:         endif</span><br><span class=\"line\">E15:      endif</span><br><span class=\"line\">E16:   endloop</span><br><span class=\"line\">       // Enqueue is done.  Try to swing Tail to the inserted node</span><br><span class=\"line\">E17:   CAS(&amp;Q-&gt;Tail, tail, &lt;node, tail.count+1&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">dequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean</span><br><span class=\"line\"> D1:   loop                 // Keep trying until Dequeue is done</span><br><span class=\"line\"> D2:      head = Q-&gt;Head         // Read Head</span><br><span class=\"line\"> D3:      tail = Q-&gt;Tail         // Read Tail</span><br><span class=\"line\"> D4:      next = head.ptr-&gt;next    // Read Head.ptr-&gt;next</span><br><span class=\"line\"> D5:      if head == Q-&gt;Head         // Are head, tail, and next consistent?</span><br><span class=\"line\"> D6:         if head.ptr == tail.ptr // Is queue empty or Tail falling behind?</span><br><span class=\"line\"> D7:            if next.ptr == NULL  // Is queue empty?</span><br><span class=\"line\"> D8:               return FALSE      // Queue is empty, couldn&#x27;t dequeue</span><br><span class=\"line\"> D9:            endif</span><br><span class=\"line\">                // Tail is falling behind.  Try to advance it</span><br><span class=\"line\">D10:            CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+1&gt;)</span><br><span class=\"line\">D11:         else             // No need to deal with Tail</span><br><span class=\"line\">                // Read value before CAS</span><br><span class=\"line\">                // Otherwise, another dequeue might free the next node</span><br><span class=\"line\">D12:            *pvalue = next.ptr-&gt;value</span><br><span class=\"line\">                // Try to swing Head to the next node</span><br><span class=\"line\">D13:            if CAS(&amp;Q-&gt;Head, head, &lt;next.ptr, head.count+1&gt;)</span><br><span class=\"line\">D14:               break             // Dequeue is done.  Exit loop</span><br><span class=\"line\">D15:            endif</span><br><span class=\"line\">D16:         endif</span><br><span class=\"line\">D17:      endif</span><br><span class=\"line\">D18:   endloop</span><br><span class=\"line\">D19:   free(head.ptr)             // It is safe now to free the old node</span><br><span class=\"line\">D20:   return TRUE                   // Queue was not empty, dequeue succeeded</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>简单起见，不考虑 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQUJBX3Byb2JsZW0=\">ABA<i class=\"fa fa-external-link-alt\"></i></span> 问题，所以没有实现带版本号的 CAS</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;sync/atomic&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;unsafe&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> lockFreeQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    head unsafe.Pointer</span><br><span class=\"line\">    tail unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span>  <span class=\"type\">int32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    next  unsafe.Pointer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLockFreeQueue</span><span class=\"params\">()</span></span> *lockFreeQueue &#123;</span><br><span class=\"line\">    n := unsafe.Pointer(&amp;node&#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;lockFreeQueue&#123;head: n, tail: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Enqueue(v <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">    n := &amp;node&#123;value: v&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tail := load(&amp;q.tail)</span><br><span class=\"line\">        next := load(&amp;tail.next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tail == load(&amp;q.tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cas(&amp;tail.next, next, n) &#123;</span><br><span class=\"line\">                    cas(&amp;q.tail, tail, n)</span><br><span class=\"line\">                    atomic.AddInt32(&amp;q.<span class=\"built_in\">len</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cas(&amp;q.tail, tail, next)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Dequeue() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        head := load(&amp;q.head)</span><br><span class=\"line\">        tail := load(&amp;q.tail)</span><br><span class=\"line\">        next := load(&amp;head.next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head == load(&amp;q.head) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head == tail &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cas(&amp;q.tail, tail, next)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                v := next.value</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cas(&amp;q.head, head, next) &#123;</span><br><span class=\"line\">                    atomic.AddInt32(&amp;q.<span class=\"built_in\">len</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *lockFreeQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atomic.LoadInt32(&amp;q.<span class=\"built_in\">len</span>) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(p *unsafe.Pointer)</span></span> *node &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*node)(atomic.LoadPointer(p))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cas</span><span class=\"params\">(p *unsafe.Pointer, old, <span class=\"built_in\">new</span> *node)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atomic.CompareAndSwapPointer(p,</span><br><span class=\"line\">        unsafe.Pointer(old), unsafe.Pointer(<span class=\"built_in\">new</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"开始第一个 Pull Request","date":"2021-09-18T07:52:39.000Z","_content":"\ngit 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。\n\n<!-- more -->\n\n## Pull Request\n\n> GitHub 简单的使用就不赘述了，这篇主要分享一下我是怎么从一个人默默玩“单机版 GitHub”，到第一次给别人的项目提交 pr\n\n首先，什么是 pr (pull request) ？在本地使用 git 的时候，有一个 merge 功能，能够进行分支合并，pr 就是 GitHub 上的 merge，它增加了代码 review 和 CI/CD 等功能。通过 pr 我们可以给别人的项目新增功能、修复 bug，在项目维护者 review 完你的代码，通过并且合并了这次 pr，你就能成为这个项目的 contributor (贡献者)\n\n## 我的第一次 PR\n\n玩 GitHub 的程序员肯定多多少少希望自己的仓库能有很多 ⭐，我也不例外，但是无奈技术还没达到大佬的级别，写不出什么好的项目或者框架。一次逛 GitHub 发现别人整理的力扣热门问题的 Go 语言题解，获得了挺多星星，于是就想自己也整理一个 Java 版本的。但也是三分热度，写了几周就没坚持下去，后来偶然看到了[杨立滨](https://github.com/yanglbme)大佬维护的 [doocs/leetcode](https://github.com/doocs/leetcode)，被 README 里的[加入我们](https://github.com/doocs/leetcode#%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC)吸引到了：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161308204.png)\n\n迈出第一步确实挺紧张，查了好多资料，然后照着 README 里的步骤打开了人生第一次 pr ([#359](https://github.com/doocs/leetcode/pull/359))，虽然有些错误，但是在大佬的指点下还是改正了过来，成功被合并。\n\n## 注意事项\n\n自己的一些小经验，一次规范的 pr 不仅减少了自己重复修改的次数，也方便了项目维护者 review\n\n### 代码格式\n\n可能每个人都有自己的编程习惯，左大括号换行或是不换行，2 空格缩进或是 4 空格缩进。自己敲代码的时候可以按习惯来，但是在提交前最好按照项目的标准格式化一遍（自己配置好格式化工具或者使用项目提供的格式化配置）\n\n### 测试\n\n项目有单元测试，修改了代码后，确保单元测试跑的通，不要提交一个显而易见的 bug。如果是文档类项目，最好在本地预览一遍（除非你很熟练，相信自己不会在 markdown 里都写出 bug）\n\n### Commit Message\n\n大部分项目对 commit message 会有一定要求，可以学习一下 Angular 的 [Commit Message Format](https://github.com/angular/angular/blob/12.2.6/CONTRIBUTING.md#commit)。另外可以使用 [cz-cli](https://github.com/commitizen/cz-cli) 很方便地写出规范的 commit message:\n\n```bash\n# 安装 cz-cli (前提得先装好 node.js)\nnpm i -g commitizen cz-conventional-changelog\necho '{ \"path\": \"cz-conventional-changelog\" }' > ~/.czrc\n\n# 像往常一样 add 然后 commit (commit 改为 cz)\ngit add .\ngit cz\n```\n\n没人不喜欢这样清晰的 commits:\n\n```bash\n$ git log --oneline\n007059963 (HEAD -> main, origin/main, origin/HEAD) feat: add solutions to lc/lcof2 problem: Asteroid Collision\n92e73c337 chore: update contributors to @doocs/leetcode\n8453df21d feat: add solutions to lc problem: No.0825.Friends Of Appropriate Ages\nf8ea6eb9d feat: add solutions to lcof2 problem:No.075\n362159f22 feat: add solutions to lc problems: No.0912,1122\n89d6e7117 feat: add solutions to lc problem: No.1869.Longer Contiguous Segments of Ones than Zeros\nb680b612c feat: add solutions to lc problem: No.1051.Height Checker\nf4ccd19bd feat: add solutions to lc problem: No.0912.Sort an Array\n2e803a22b feat: add solutions to lcof2 problem: No.046\n6421c40d3 chore: update contributors to @doocs/leetcode\nf41bad246 feat: add cpp solution to lcof2 problem: NO.046 (#567)\n......\n```\n\n## 最后\n\n打一波广告，欢迎喜欢刷题的小伙伴加入我们\n\n[![leetcode](https://github-readme-stats.vercel.app/api/pin/?username=doocs&repo=leetcode&show_owner=true)](https://github.com/doocs/leetcode)\n","source":"_posts/github/first-pr.md","raw":"---\ntitle: 开始第一个 Pull Request\ndate: 2021-09-18 15:52:39\ncategories: GitHub\ntags:\n  - LeetCode\n---\n\ngit 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。\n\n<!-- more -->\n\n## Pull Request\n\n> GitHub 简单的使用就不赘述了，这篇主要分享一下我是怎么从一个人默默玩“单机版 GitHub”，到第一次给别人的项目提交 pr\n\n首先，什么是 pr (pull request) ？在本地使用 git 的时候，有一个 merge 功能，能够进行分支合并，pr 就是 GitHub 上的 merge，它增加了代码 review 和 CI/CD 等功能。通过 pr 我们可以给别人的项目新增功能、修复 bug，在项目维护者 review 完你的代码，通过并且合并了这次 pr，你就能成为这个项目的 contributor (贡献者)\n\n## 我的第一次 PR\n\n玩 GitHub 的程序员肯定多多少少希望自己的仓库能有很多 ⭐，我也不例外，但是无奈技术还没达到大佬的级别，写不出什么好的项目或者框架。一次逛 GitHub 发现别人整理的力扣热门问题的 Go 语言题解，获得了挺多星星，于是就想自己也整理一个 Java 版本的。但也是三分热度，写了几周就没坚持下去，后来偶然看到了[杨立滨](https://github.com/yanglbme)大佬维护的 [doocs/leetcode](https://github.com/doocs/leetcode)，被 README 里的[加入我们](https://github.com/doocs/leetcode#%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC)吸引到了：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161308204.png)\n\n迈出第一步确实挺紧张，查了好多资料，然后照着 README 里的步骤打开了人生第一次 pr ([#359](https://github.com/doocs/leetcode/pull/359))，虽然有些错误，但是在大佬的指点下还是改正了过来，成功被合并。\n\n## 注意事项\n\n自己的一些小经验，一次规范的 pr 不仅减少了自己重复修改的次数，也方便了项目维护者 review\n\n### 代码格式\n\n可能每个人都有自己的编程习惯，左大括号换行或是不换行，2 空格缩进或是 4 空格缩进。自己敲代码的时候可以按习惯来，但是在提交前最好按照项目的标准格式化一遍（自己配置好格式化工具或者使用项目提供的格式化配置）\n\n### 测试\n\n项目有单元测试，修改了代码后，确保单元测试跑的通，不要提交一个显而易见的 bug。如果是文档类项目，最好在本地预览一遍（除非你很熟练，相信自己不会在 markdown 里都写出 bug）\n\n### Commit Message\n\n大部分项目对 commit message 会有一定要求，可以学习一下 Angular 的 [Commit Message Format](https://github.com/angular/angular/blob/12.2.6/CONTRIBUTING.md#commit)。另外可以使用 [cz-cli](https://github.com/commitizen/cz-cli) 很方便地写出规范的 commit message:\n\n```bash\n# 安装 cz-cli (前提得先装好 node.js)\nnpm i -g commitizen cz-conventional-changelog\necho '{ \"path\": \"cz-conventional-changelog\" }' > ~/.czrc\n\n# 像往常一样 add 然后 commit (commit 改为 cz)\ngit add .\ngit cz\n```\n\n没人不喜欢这样清晰的 commits:\n\n```bash\n$ git log --oneline\n007059963 (HEAD -> main, origin/main, origin/HEAD) feat: add solutions to lc/lcof2 problem: Asteroid Collision\n92e73c337 chore: update contributors to @doocs/leetcode\n8453df21d feat: add solutions to lc problem: No.0825.Friends Of Appropriate Ages\nf8ea6eb9d feat: add solutions to lcof2 problem:No.075\n362159f22 feat: add solutions to lc problems: No.0912,1122\n89d6e7117 feat: add solutions to lc problem: No.1869.Longer Contiguous Segments of Ones than Zeros\nb680b612c feat: add solutions to lc problem: No.1051.Height Checker\nf4ccd19bd feat: add solutions to lc problem: No.0912.Sort an Array\n2e803a22b feat: add solutions to lcof2 problem: No.046\n6421c40d3 chore: update contributors to @doocs/leetcode\nf41bad246 feat: add cpp solution to lcof2 problem: NO.046 (#567)\n......\n```\n\n## 最后\n\n打一波广告，欢迎喜欢刷题的小伙伴加入我们\n\n[![leetcode](https://github-readme-stats.vercel.app/api/pin/?username=doocs&repo=leetcode&show_owner=true)](https://github.com/doocs/leetcode)\n","slug":"github/first-pr","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczds0009xeoa5mqw6lyo","content":"<p>git 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Pull-Request\"><a href=\"#Pull-Request\" class=\"headerlink\" title=\"Pull Request\"></a>Pull Request</h2><blockquote>\n<p>GitHub 简单的使用就不赘述了，这篇主要分享一下我是怎么从一个人默默玩“单机版 GitHub”，到第一次给别人的项目提交 pr</p>\n</blockquote>\n<p>首先，什么是 pr (pull request) ？在本地使用 git 的时候，有一个 merge 功能，能够进行分支合并，pr 就是 GitHub 上的 merge，它增加了代码 review 和 CI&#x2F;CD 等功能。通过 pr 我们可以给别人的项目新增功能、修复 bug，在项目维护者 review 完你的代码，通过并且合并了这次 pr，你就能成为这个项目的 contributor (贡献者)</p>\n<h2 id=\"我的第一次-PR\"><a href=\"#我的第一次-PR\" class=\"headerlink\" title=\"我的第一次 PR\"></a>我的第一次 PR</h2><p>玩 GitHub 的程序员肯定多多少少希望自己的仓库能有很多 ⭐，我也不例外，但是无奈技术还没达到大佬的级别，写不出什么好的项目或者框架。一次逛 GitHub 发现别人整理的力扣热门问题的 Go 语言题解，获得了挺多星星，于是就想自己也整理一个 Java 版本的。但也是三分热度，写了几周就没坚持下去，后来偶然看到了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3lhbmdsYm1l\">杨立滨<i class=\"fa fa-external-link-alt\"></i></span>大佬维护的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2Rl\">doocs&#x2F;leetcode<i class=\"fa fa-external-link-alt\"></i></span>，被 README 里的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlIyVFNSU4QSVBMCVFNSU4NSVBNSVFNiU4OCU5MSVFNCVCQiVBQw==\">加入我们<i class=\"fa fa-external-link-alt\"></i></span>吸引到了：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161308204.png\" loading=\"lazy\"></p>\n<p>迈出第一步确实挺紧张，查了好多资料，然后照着 README 里的步骤打开了人生第一次 pr (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlL3B1bGwvMzU5\">#359<i class=\"fa fa-external-link-alt\"></i></span>)，虽然有些错误，但是在大佬的指点下还是改正了过来，成功被合并。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>自己的一些小经验，一次规范的 pr 不仅减少了自己重复修改的次数，也方便了项目维护者 review</p>\n<h3 id=\"代码格式\"><a href=\"#代码格式\" class=\"headerlink\" title=\"代码格式\"></a>代码格式</h3><p>可能每个人都有自己的编程习惯，左大括号换行或是不换行，2 空格缩进或是 4 空格缩进。自己敲代码的时候可以按习惯来，但是在提交前最好按照项目的标准格式化一遍（自己配置好格式化工具或者使用项目提供的格式化配置）</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>项目有单元测试，修改了代码后，确保单元测试跑的通，不要提交一个显而易见的 bug。如果是文档类项目，最好在本地预览一遍（除非你很熟练，相信自己不会在 markdown 里都写出 bug）</p>\n<h3 id=\"Commit-Message\"><a href=\"#Commit-Message\" class=\"headerlink\" title=\"Commit Message\"></a>Commit Message</h3><p>大部分项目对 commit message 会有一定要求，可以学习一下 Angular 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIuNi9DT05UUklCVVRJTkcubWQjY29tbWl0\">Commit Message Format<i class=\"fa fa-external-link-alt\"></i></span>。另外可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbW1pdGl6ZW4vY3otY2xp\">cz-cli<i class=\"fa fa-external-link-alt\"></i></span> 很方便地写出规范的 commit message:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 cz-cli (前提得先装好 node.js)</span></span><br><span class=\"line\">npm i -g commitizen cz-conventional-changelog</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27;</span> &gt; ~/.czrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 像往常一样 add 然后 commit (commit 改为 cz)</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git cz</span><br></pre></td></tr></table></figure>\n\n<p>没人不喜欢这样清晰的 commits:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --oneline</span><br><span class=\"line\">007059963 (HEAD -&gt; main, origin/main, origin/HEAD) feat: add solutions to lc/lcof2 problem: Asteroid Collision</span><br><span class=\"line\">92e73c337 chore: update contributors to @doocs/leetcode</span><br><span class=\"line\">8453df21d feat: add solutions to lc problem: No.0825.Friends Of Appropriate Ages</span><br><span class=\"line\">f8ea6eb9d feat: add solutions to lcof2 problem:No.075</span><br><span class=\"line\">362159f22 feat: add solutions to lc problems: No.0912,1122</span><br><span class=\"line\">89d6e7117 feat: add solutions to lc problem: No.1869.Longer Contiguous Segments of Ones than Zeros</span><br><span class=\"line\">b680b612c feat: add solutions to lc problem: No.1051.Height Checker</span><br><span class=\"line\">f4ccd19bd feat: add solutions to lc problem: No.0912.Sort an Array</span><br><span class=\"line\">2e803a22b feat: add solutions to lcof2 problem: No.046</span><br><span class=\"line\">6421c40d3 chore: update contributors to @doocs/leetcode</span><br><span class=\"line\">f41bad246 feat: add cpp solution to lcof2 problem: NO.046 (<span class=\"comment\">#567)</span></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>打一波广告，欢迎喜欢刷题的小伙伴加入我们</p>\n<p><a href=\"https://github.com/doocs/leetcode\"><img data-src=\"https://github-readme-stats.vercel.app/api/pin/?username=doocs&repo=leetcode&show_owner=true\" alt=\"leetcode\" loading=\"lazy\"></a></p>\n","site":{"data":{}},"length":1930,"excerpt":"<p>git 几乎是所有程序员必须掌握的一个工具，但是始终在本地练习似乎发现不了它真正的强大，于是目光就转向了 GitHub 这个提供了仓库托管服务的网站。在 GitHub 上我们能利用 git 和世界各地的程序员协作开发，分享有趣的代码。</p>","more":"<h2 id=\"Pull-Request\"><a href=\"#Pull-Request\" class=\"headerlink\" title=\"Pull Request\"></a>Pull Request</h2><blockquote>\n<p>GitHub 简单的使用就不赘述了，这篇主要分享一下我是怎么从一个人默默玩“单机版 GitHub”，到第一次给别人的项目提交 pr</p>\n</blockquote>\n<p>首先，什么是 pr (pull request) ？在本地使用 git 的时候，有一个 merge 功能，能够进行分支合并，pr 就是 GitHub 上的 merge，它增加了代码 review 和 CI&#x2F;CD 等功能。通过 pr 我们可以给别人的项目新增功能、修复 bug，在项目维护者 review 完你的代码，通过并且合并了这次 pr，你就能成为这个项目的 contributor (贡献者)</p>\n<h2 id=\"我的第一次-PR\"><a href=\"#我的第一次-PR\" class=\"headerlink\" title=\"我的第一次 PR\"></a>我的第一次 PR</h2><p>玩 GitHub 的程序员肯定多多少少希望自己的仓库能有很多 ⭐，我也不例外，但是无奈技术还没达到大佬的级别，写不出什么好的项目或者框架。一次逛 GitHub 发现别人整理的力扣热门问题的 Go 语言题解，获得了挺多星星，于是就想自己也整理一个 Java 版本的。但也是三分热度，写了几周就没坚持下去，后来偶然看到了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3lhbmdsYm1l\">杨立滨<i class=\"fa fa-external-link-alt\"></i></span>大佬维护的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2Rl\">doocs&#x2F;leetcode<i class=\"fa fa-external-link-alt\"></i></span>，被 README 里的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlIyVFNSU4QSVBMCVFNSU4NSVBNSVFNiU4OCU5MSVFNCVCQiVBQw==\">加入我们<i class=\"fa fa-external-link-alt\"></i></span>吸引到了：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202111161308204.png\" loading=\"lazy\"></p>\n<p>迈出第一步确实挺紧张，查了好多资料，然后照着 README 里的步骤打开了人生第一次 pr (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Rvb2NzL2xlZXRjb2RlL3B1bGwvMzU5\">#359<i class=\"fa fa-external-link-alt\"></i></span>)，虽然有些错误，但是在大佬的指点下还是改正了过来，成功被合并。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>自己的一些小经验，一次规范的 pr 不仅减少了自己重复修改的次数，也方便了项目维护者 review</p>\n<h3 id=\"代码格式\"><a href=\"#代码格式\" class=\"headerlink\" title=\"代码格式\"></a>代码格式</h3><p>可能每个人都有自己的编程习惯，左大括号换行或是不换行，2 空格缩进或是 4 空格缩进。自己敲代码的时候可以按习惯来，但是在提交前最好按照项目的标准格式化一遍（自己配置好格式化工具或者使用项目提供的格式化配置）</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>项目有单元测试，修改了代码后，确保单元测试跑的通，不要提交一个显而易见的 bug。如果是文档类项目，最好在本地预览一遍（除非你很熟练，相信自己不会在 markdown 里都写出 bug）</p>\n<h3 id=\"Commit-Message\"><a href=\"#Commit-Message\" class=\"headerlink\" title=\"Commit Message\"></a>Commit Message</h3><p>大部分项目对 commit message 会有一定要求，可以学习一下 Angular 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIuNi9DT05UUklCVVRJTkcubWQjY29tbWl0\">Commit Message Format<i class=\"fa fa-external-link-alt\"></i></span>。另外可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbW1pdGl6ZW4vY3otY2xp\">cz-cli<i class=\"fa fa-external-link-alt\"></i></span> 很方便地写出规范的 commit message:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 cz-cli (前提得先装好 node.js)</span></span><br><span class=\"line\">npm i -g commitizen cz-conventional-changelog</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27;</span> &gt; ~/.czrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 像往常一样 add 然后 commit (commit 改为 cz)</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git cz</span><br></pre></td></tr></table></figure>\n\n<p>没人不喜欢这样清晰的 commits:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --oneline</span><br><span class=\"line\">007059963 (HEAD -&gt; main, origin/main, origin/HEAD) feat: add solutions to lc/lcof2 problem: Asteroid Collision</span><br><span class=\"line\">92e73c337 chore: update contributors to @doocs/leetcode</span><br><span class=\"line\">8453df21d feat: add solutions to lc problem: No.0825.Friends Of Appropriate Ages</span><br><span class=\"line\">f8ea6eb9d feat: add solutions to lcof2 problem:No.075</span><br><span class=\"line\">362159f22 feat: add solutions to lc problems: No.0912,1122</span><br><span class=\"line\">89d6e7117 feat: add solutions to lc problem: No.1869.Longer Contiguous Segments of Ones than Zeros</span><br><span class=\"line\">b680b612c feat: add solutions to lc problem: No.1051.Height Checker</span><br><span class=\"line\">f4ccd19bd feat: add solutions to lc problem: No.0912.Sort an Array</span><br><span class=\"line\">2e803a22b feat: add solutions to lcof2 problem: No.046</span><br><span class=\"line\">6421c40d3 chore: update contributors to @doocs/leetcode</span><br><span class=\"line\">f41bad246 feat: add cpp solution to lcof2 problem: NO.046 (<span class=\"comment\">#567)</span></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>打一波广告，欢迎喜欢刷题的小伙伴加入我们</p>\n<p><a href=\"https://github.com/doocs/leetcode\"><img data-src=\"https://github-readme-stats.vercel.app/api/pin/?username=doocs&repo=leetcode&show_owner=true\" alt=\"leetcode\" loading=\"lazy\"></a></p>"},{"title":"【Java 并发】重入锁（ReentrantLock）","date":"2020-11-24T08:13:45.000Z","_content":"\n## 什么是“重入”\n\nRe-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复**仅仅局限于一个线程**，观察下面的代码， `f1` 锁住 `lock` 之后， `f2` 依然能继续获取到 `lock` 并执行，因为它们都属于主线程。\n\n<!-- more -->\n\n```java\npublic class Main {\n\n    static class Test {\n        private final ReentrantLock lock = new ReentrantLock();\n\n        public void f1() {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName());\n                f2();\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        public void f2() {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName());\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.f1();\n    }\n}\n```\n\n## 重入锁 VS synchronized\n\n重入锁可以完全替代 `synchronized` 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 `synchronized` ，但从 JDK 6.0 开始，JDK 在 `synchronized` 上做了大量的优化，使得两者的性能差距并不大。\n\n用两种方法分别实现 `num++`：\n\n### 重入锁\n\n```java\npublic class Main {\n\n    static int num = 0;\n    static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread[] ts = new Thread[32];\n        Runnable runnable = () -> {\n            for (int i = 0; i < 10000; i++) {\n                lock.lock();\n                try {\n                    num++;\n                } finally {\n                    lock.unlock();\n                }\n            }\n        };\n        for (int i = 0; i < 32; i++) {\n            ts[i] = new Thread(runnable);\n            ts[i].start();\n        }\n        for (int i = 0; i < 32; i++) {\n            ts[i].join();\n        }\n        System.out.println(num);\n    }\n}\n```\n\n### synchronized\n\n```java\npublic class Main {\n\n    static int num = 0;\n    static Object obj = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread[] ts = new Thread[32];\n        Runnable runnable = () -> {\n            for (int i = 0; i < 10000; i++) {\n                synchronized (obj) {\n                    num++;\n                }\n            }\n        };\n        for (int i = 0; i < 32; i++) {\n            ts[i] = new Thread(runnable);\n            ts[i].start();\n        }\n        for (int i = 0; i < 32; i++) {\n            ts[i].join();\n        }\n        System.out.println(num);\n    }\n}\n```\n\n## 响应中断\n\n对于 `synchronized` 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。\n\n模拟一个死锁的场景：两个线程都需要获取 `lock1`, `lock2` 两把锁，线程 `t1` 先获取了 `lock1` ，线程 `t2` 先获取了 `lock2` ，然后它们就开始无限等待对方让出锁。但是这个时候，如果中断了线程 `t2` ，并且释放 `t2` 占有的锁， `t1` 就能正常运行：\n\n```java\npublic class Main {\n\n    static class IntLock implements Runnable {\n        private static ReentrantLock lock1 = new ReentrantLock();\n        private static ReentrantLock lock2 = new ReentrantLock();\n        private int lock;\n\n        public IntLock(int lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (lock == 1) {\n                    lock1.lockInterruptibly();\n                    try {\n                        Thread.sleep(500);\n                        lock2.lockInterruptibly();\n                        try {\n                            System.out.println(\"t1成功获取两把锁\");\n                        } finally {\n                            lock2.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        System.out.println(\"t1被中断\");\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        lock1.unlock();\n                    }\n                } else {\n                    lock2.lockInterruptibly();\n                    try {\n                        Thread.sleep(500);\n                        lock1.lockInterruptibly();\n                        try {\n                            System.out.println(\"t2成功获取两把锁\");\n                        } finally {\n                            lock1.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        System.out.println(\"t2被中断\");\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        lock2.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        IntLock r1 = new IntLock(1);\n        IntLock r2 = new IntLock(2);\n        Thread t1 = new Thread(r1);\n        Thread t2 = new Thread(r2);\n        t1.start();\n        t2.start();\n        Thread.sleep(1000);\n        t2.interrupt();\n    }\n}\n```\n\n## 锁申请等待限时\n\n`tryLock()` 方法接收两个参数，一个表示等待时长，另外一个表示计时单位。也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 `true` 。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 `false`。\n\n```java\npublic class Main {\n\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Runnable target = () -> {\n            try {\n                if (lock.tryLock(1, TimeUnit.SECONDS)) {\n                    System.out.println(Thread.currentThread().getName() + \" get lock success\");\n                    Thread.sleep(4000);\n                } else {\n                    System.out.println(Thread.currentThread().getName() + \" get lock failed\");\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                if (lock.isHeldByCurrentThread()) {\n                    lock.unlock();\n                }\n            }\n        };\n        Thread t1 = new Thread(target);\n        Thread t2 = new Thread(target);\n        t1.start();\n        t2.start();\n    }\n\n}\n```\n\n## 公平锁\n\n在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄得围在售票窗口前，售票员忙得焦头烂额，也顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：\n\n```java\npublic ReentrantLock(boolean fair)\n```\n\n当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个**有序队列**，因此公平锁的实现成本比较高，性能相对也非常低下，因此，**默认情况下，锁是非公平的**。如果没有特别的需求，也不需要使用公平锁。公平锁和非公平锁在线程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：\n\n```java\npublic class Main {\n\n    private static ReentrantLock fairLock = new ReentrantLock(true);\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable target = () -> {\n            while (!Thread.currentThread().isInterrupted()) {\n                fairLock.lock();\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 获得锁\");\n                } finally {\n                    fairLock.unlock();\n                }\n            }\n        };\n        Thread t1 = new Thread(target);\n        Thread t2 = new Thread(target);\n        t1.start();\n        t2.start();\n        Thread.sleep(1000);\n        t1.interrupt();\n        t2.interrupt();\n    }\n\n}\n```\n\n从运行结果可以看出，大部分情况下，两个线程是交替运行的。\n\n```text\n...\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\n...\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\n...\n```\n\n但是换成非公平锁之后，会发现连续多次都是同一个线程获取锁。\n\n```text\n...\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\n...\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\n...\n```\n","source":"_posts/java/reentrant-lock.md","raw":"---\ntitle: 【Java 并发】重入锁（ReentrantLock）\ndate: 2020-11-24 16:13:45\ncategories: Java\ntags:\n  - 并发\n---\n\n## 什么是“重入”\n\nRe-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复**仅仅局限于一个线程**，观察下面的代码， `f1` 锁住 `lock` 之后， `f2` 依然能继续获取到 `lock` 并执行，因为它们都属于主线程。\n\n<!-- more -->\n\n```java\npublic class Main {\n\n    static class Test {\n        private final ReentrantLock lock = new ReentrantLock();\n\n        public void f1() {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName());\n                f2();\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        public void f2() {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName());\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.f1();\n    }\n}\n```\n\n## 重入锁 VS synchronized\n\n重入锁可以完全替代 `synchronized` 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 `synchronized` ，但从 JDK 6.0 开始，JDK 在 `synchronized` 上做了大量的优化，使得两者的性能差距并不大。\n\n用两种方法分别实现 `num++`：\n\n### 重入锁\n\n```java\npublic class Main {\n\n    static int num = 0;\n    static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread[] ts = new Thread[32];\n        Runnable runnable = () -> {\n            for (int i = 0; i < 10000; i++) {\n                lock.lock();\n                try {\n                    num++;\n                } finally {\n                    lock.unlock();\n                }\n            }\n        };\n        for (int i = 0; i < 32; i++) {\n            ts[i] = new Thread(runnable);\n            ts[i].start();\n        }\n        for (int i = 0; i < 32; i++) {\n            ts[i].join();\n        }\n        System.out.println(num);\n    }\n}\n```\n\n### synchronized\n\n```java\npublic class Main {\n\n    static int num = 0;\n    static Object obj = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread[] ts = new Thread[32];\n        Runnable runnable = () -> {\n            for (int i = 0; i < 10000; i++) {\n                synchronized (obj) {\n                    num++;\n                }\n            }\n        };\n        for (int i = 0; i < 32; i++) {\n            ts[i] = new Thread(runnable);\n            ts[i].start();\n        }\n        for (int i = 0; i < 32; i++) {\n            ts[i].join();\n        }\n        System.out.println(num);\n    }\n}\n```\n\n## 响应中断\n\n对于 `synchronized` 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。\n\n模拟一个死锁的场景：两个线程都需要获取 `lock1`, `lock2` 两把锁，线程 `t1` 先获取了 `lock1` ，线程 `t2` 先获取了 `lock2` ，然后它们就开始无限等待对方让出锁。但是这个时候，如果中断了线程 `t2` ，并且释放 `t2` 占有的锁， `t1` 就能正常运行：\n\n```java\npublic class Main {\n\n    static class IntLock implements Runnable {\n        private static ReentrantLock lock1 = new ReentrantLock();\n        private static ReentrantLock lock2 = new ReentrantLock();\n        private int lock;\n\n        public IntLock(int lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (lock == 1) {\n                    lock1.lockInterruptibly();\n                    try {\n                        Thread.sleep(500);\n                        lock2.lockInterruptibly();\n                        try {\n                            System.out.println(\"t1成功获取两把锁\");\n                        } finally {\n                            lock2.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        System.out.println(\"t1被中断\");\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        lock1.unlock();\n                    }\n                } else {\n                    lock2.lockInterruptibly();\n                    try {\n                        Thread.sleep(500);\n                        lock1.lockInterruptibly();\n                        try {\n                            System.out.println(\"t2成功获取两把锁\");\n                        } finally {\n                            lock1.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        System.out.println(\"t2被中断\");\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        lock2.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        IntLock r1 = new IntLock(1);\n        IntLock r2 = new IntLock(2);\n        Thread t1 = new Thread(r1);\n        Thread t2 = new Thread(r2);\n        t1.start();\n        t2.start();\n        Thread.sleep(1000);\n        t2.interrupt();\n    }\n}\n```\n\n## 锁申请等待限时\n\n`tryLock()` 方法接收两个参数，一个表示等待时长，另外一个表示计时单位。也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 `true` 。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 `false`。\n\n```java\npublic class Main {\n\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Runnable target = () -> {\n            try {\n                if (lock.tryLock(1, TimeUnit.SECONDS)) {\n                    System.out.println(Thread.currentThread().getName() + \" get lock success\");\n                    Thread.sleep(4000);\n                } else {\n                    System.out.println(Thread.currentThread().getName() + \" get lock failed\");\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                if (lock.isHeldByCurrentThread()) {\n                    lock.unlock();\n                }\n            }\n        };\n        Thread t1 = new Thread(target);\n        Thread t2 = new Thread(target);\n        t1.start();\n        t2.start();\n    }\n\n}\n```\n\n## 公平锁\n\n在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄得围在售票窗口前，售票员忙得焦头烂额，也顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：\n\n```java\npublic ReentrantLock(boolean fair)\n```\n\n当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个**有序队列**，因此公平锁的实现成本比较高，性能相对也非常低下，因此，**默认情况下，锁是非公平的**。如果没有特别的需求，也不需要使用公平锁。公平锁和非公平锁在线程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：\n\n```java\npublic class Main {\n\n    private static ReentrantLock fairLock = new ReentrantLock(true);\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable target = () -> {\n            while (!Thread.currentThread().isInterrupted()) {\n                fairLock.lock();\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 获得锁\");\n                } finally {\n                    fairLock.unlock();\n                }\n            }\n        };\n        Thread t1 = new Thread(target);\n        Thread t2 = new Thread(target);\n        t1.start();\n        t2.start();\n        Thread.sleep(1000);\n        t1.interrupt();\n        t2.interrupt();\n    }\n\n}\n```\n\n从运行结果可以看出，大部分情况下，两个线程是交替运行的。\n\n```text\n...\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\n...\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\nThread-1 获得锁\nThread-0 获得锁\n...\n```\n\n但是换成非公平锁之后，会发现连续多次都是同一个线程获取锁。\n\n```text\n...\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\nThread-0 获得锁\n...\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\nThread-1 获得锁\n...\n```\n","slug":"java/reentrant-lock","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdu000cxeoafq5f8b4m","content":"<h2 id=\"什么是“重入”\"><a href=\"#什么是“重入”\" class=\"headerlink\" title=\"什么是“重入”\"></a>什么是“重入”</h2><p>Re-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复<strong>仅仅局限于一个线程</strong>，观察下面的代码， <code>f1</code> 锁住 <code>lock</code> 之后， <code>f2</code> 依然能继续获取到 <code>lock</code> 并执行，因为它们都属于主线程。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                f2();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test</span>();</span><br><span class=\"line\">        test.f1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重入锁-VS-synchronized\"><a href=\"#重入锁-VS-synchronized\" class=\"headerlink\" title=\"重入锁 VS synchronized\"></a>重入锁 VS synchronized</h2><p>重入锁可以完全替代 <code>synchronized</code> 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 <code>synchronized</code> ，但从 JDK 6.0 开始，JDK 在 <code>synchronized</code> 上做了大量的优化，使得两者的性能差距并不大。</p>\n<p>用两种方法分别实现 <code>num++</code>：</p>\n<h3 id=\"重入锁\"><a href=\"#重入锁\" class=\"headerlink\" title=\"重入锁\"></a>重入锁</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        Thread[] ts = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    num++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">            ts[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i].join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        Thread[] ts = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (obj) &#123;</span><br><span class=\"line\">                    num++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">            ts[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i].join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h2><p>对于 <code>synchronized</code> 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。</p>\n<p>模拟一个死锁的场景：两个线程都需要获取 <code>lock1</code>, <code>lock2</code> 两把锁，线程 <code>t1</code> 先获取了 <code>lock1</code> ，线程 <code>t2</code> 先获取了 <code>lock2</code> ，然后它们就开始无限等待对方让出锁。但是这个时候，如果中断了线程 <code>t2</code> ，并且释放 <code>t2</code> 占有的锁， <code>t1</code> 就能正常运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IntLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> lock;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">IntLock</span><span class=\"params\">(<span class=\"type\">int</span> lock)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    lock1.lockInterruptibly();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        lock2.lockInterruptibly();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;t1成功获取两把锁&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            lock2.unlock();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;t1被中断&quot;</span>);</span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        lock1.unlock();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lock2.lockInterruptibly();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        lock1.lockInterruptibly();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;t2成功获取两把锁&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            lock1.unlock();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;t2被中断&quot;</span>);</span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        lock2.unlock();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">IntLock</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntLock</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">IntLock</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntLock</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r1);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r2);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t2.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"锁申请等待限时\"><a href=\"#锁申请等待限时\" class=\"headerlink\" title=\"锁申请等待限时\"></a>锁申请等待限时</h2><p><code>tryLock()</code> 方法接收两个参数，一个表示等待时长，另外一个表示计时单位。也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 <code>true</code> 。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 <code>false</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; get lock success&quot;</span>);</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; get lock failed&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h2><p>在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄得围在售票窗口前，售票员忙得焦头烂额，也顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ReentrantLock</span><span class=\"params\">(<span class=\"type\">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>\n\n<p>当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个<strong>有序队列</strong>，因此公平锁的实现成本比较高，性能相对也非常低下，因此，<strong>默认情况下，锁是非公平的</strong>。如果没有特别的需求，也不需要使用公平锁。公平锁和非公平锁在线程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">fairLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                fairLock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 获得锁&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    fairLock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t1.interrupt();</span><br><span class=\"line\">        t2.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从运行结果可以看出，大部分情况下，两个线程是交替运行的。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>但是换成非公平锁之后，会发现连续多次都是同一个线程获取锁。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":5302,"excerpt":"<h2 id=\"什么是“重入”\"><a href=\"#什么是“重入”\" class=\"headerlink\" title=\"什么是“重入”\"></a>什么是“重入”</h2><p>Re-Entrant-Lock 翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然，这里的反复<strong>仅仅局限于一个线程</strong>，观察下面的代码， <code>f1</code> 锁住 <code>lock</code> 之后， <code>f2</code> 依然能继续获取到 <code>lock</code> 并执行，因为它们都属于主线程。</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                f2();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test</span>();</span><br><span class=\"line\">        test.f1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重入锁-VS-synchronized\"><a href=\"#重入锁-VS-synchronized\" class=\"headerlink\" title=\"重入锁 VS synchronized\"></a>重入锁 VS synchronized</h2><p>重入锁可以完全替代 <code>synchronized</code> 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 <code>synchronized</code> ，但从 JDK 6.0 开始，JDK 在 <code>synchronized</code> 上做了大量的优化，使得两者的性能差距并不大。</p>\n<p>用两种方法分别实现 <code>num++</code>：</p>\n<h3 id=\"重入锁\"><a href=\"#重入锁\" class=\"headerlink\" title=\"重入锁\"></a>重入锁</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        Thread[] ts = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    num++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">            ts[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i].join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        Thread[] ts = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (obj) &#123;</span><br><span class=\"line\">                    num++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(runnable);</span><br><span class=\"line\">            ts[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            ts[i].join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h2><p>对于 <code>synchronized</code> 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。</p>\n<p>模拟一个死锁的场景：两个线程都需要获取 <code>lock1</code>, <code>lock2</code> 两把锁，线程 <code>t1</code> 先获取了 <code>lock1</code> ，线程 <code>t2</code> 先获取了 <code>lock2</code> ，然后它们就开始无限等待对方让出锁。但是这个时候，如果中断了线程 <code>t2</code> ，并且释放 <code>t2</code> 占有的锁， <code>t1</code> 就能正常运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IntLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> lock;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">IntLock</span><span class=\"params\">(<span class=\"type\">int</span> lock)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.lock = lock;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    lock1.lockInterruptibly();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        lock2.lockInterruptibly();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;t1成功获取两把锁&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            lock2.unlock();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;t1被中断&quot;</span>);</span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        lock1.unlock();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lock2.lockInterruptibly();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        lock1.lockInterruptibly();</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;t2成功获取两把锁&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            lock1.unlock();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;t2被中断&quot;</span>);</span><br><span class=\"line\">                        Thread.currentThread().interrupt();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        lock2.unlock();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">IntLock</span> <span class=\"variable\">r1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntLock</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">IntLock</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntLock</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r1);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r2);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t2.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"锁申请等待限时\"><a href=\"#锁申请等待限时\" class=\"headerlink\" title=\"锁申请等待限时\"></a>锁申请等待限时</h2><p><code>tryLock()</code> 方法接收两个参数，一个表示等待时长，另外一个表示计时单位。也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 <code>true</code> 。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 <code>false</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; get lock success&quot;</span>);</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; get lock failed&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h2><p>在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只是会从这个锁的等待队列中随机挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄得围在售票窗口前，售票员忙得焦头烂额，也顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ReentrantLock</span><span class=\"params\">(<span class=\"type\">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>\n\n<p>当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个<strong>有序队列</strong>，因此公平锁的实现成本比较高，性能相对也非常低下，因此，<strong>默认情况下，锁是非公平的</strong>。如果没有特别的需求，也不需要使用公平锁。公平锁和非公平锁在线程调度表现上也是非常不一样的。下面的代码可以很好地突出公平锁的特点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">fairLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                fairLock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 获得锁&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    fairLock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(target);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t1.interrupt();</span><br><span class=\"line\">        t2.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从运行结果可以看出，大部分情况下，两个线程是交替运行的。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>但是换成非公平锁之后，会发现连续多次都是同一个线程获取锁。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">Thread-0 获得锁</span><br><span class=\"line\">...</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">Thread-1 获得锁</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>"},{"title":"【Java 并发】volatile 关键字基本理解与使用","date":"2020-11-24T08:15:22.000Z","_content":"\n## volatile 的三个特性\n\n- 保证可见性\n- **不保证原子性**\n- 禁止指令重排\n\n## 指令重排\n\n### 什么是指令重排\n\n处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n<!-- more -->\n\n可能发生重排的代码：（意思就是第二行代码可能会先执行，听起来是不是有点匪夷所思）\n\n```java\na = 1;\nb = 2;\n```\n\n一定不会重排的代码（因为第 2 行依赖第 1 行的结果）：\n\n```java\na = 2;\nb += a;\n```\n\n### 举栗子\n\n观察下面这段代码的运行结果，假设没有重排，那么运行结果只有可能是以下 3 种：\n\n- x = 1, y = 1（先执行了 `a = 1` , `b = 1` 再执行 `x = b` 和 `y = a`）\n- x = 0, y = 1（先执行了 `a = 1` , `x = b` 再执行 `b = 1` 和 `y = a`）\n- x = 1, y = 0（先执行了 `b = 1` , `y = a` 再执行 `a = 1` 和 `x = b`）\n\n```java\npublic class Main {\n\n    private static int x;\n    private static int y;\n    private static int a;\n    private static int b;\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            x = y = a = b = 0;\n\n            Thread t1 = new Thread(() -> {\n                a = 1;\n                x = b;\n            });\n\n            Thread t2 = new Thread(() -> {\n                b = 1;\n                y = a;\n            });\n\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n\n            System.out.println(\"i = \" + i + \", x = \" + x + \", y = \" + y);\n            if (x == 0 && y == 0) {\n                break;\n            }\n        }\n    }\n}\n```\n\n大概在运行几万次后会出现指令重排的现象，先执行了 `x = b` , `y = a` 再执行 `a = 1` 和 `b = 1`。结果就是 x 和 y 都等于 0。\n\n**解决办法**：给四个变量加上 `volatile` 关键字，就不会出现预期之外的重排了。\n\n## 可见性\n\n首先看一段代码：\n\n```java\npublic class Main {\n    private static boolean flag = true;\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        flag = false;\n    }\n\n}\n```\n\n执行结果应该是符合我们预期的，由于主线程修改 `flag = false` ，所以终止了另一个线程中的死循环。\n\n但是如果在 `flag = false` 前，让主线程睡一会：\n\n```java\npublic class Main {\n    private static boolean flag = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        Thread.sleep(1000);\n        flag = false;\n    }\n\n}\n```\n\n结果发现程序无法停止（依然处于死循环），这就体现了可见性的问题。每一个线程都会从**主存**中拷贝一份 `flag` 的副本到自己的**工作内存**，主线程中修改 `flag` 相当于修改了副本的值，然后再把副本的值刷到主存中。但是这个时候另一个线程并不知道主存中发生了什么变动， `while (flag)` 使用的依然是之前旧的副本，所以就导致了死循环，程序无法退出。（第一个例子是因为主线程跑得太快，在另一个线程开始从主存拷贝 `flag` 之前就已经把 `flag = false` 刷到主存里了）\n\n加上 `volatile` 关键字后：\n\n```java\npublic class Main {\n    private volatile static boolean flag = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        Thread.sleep(1000);\n        flag = false;\n    }\n\n}\n```\n\n程序成功退出。原因是主线程把 `flag` 刷到主存的同时会使其他线程的 `flag` 副本失效，下一次再判断 `while (flag)` 的时候就会重新从主存读取。\n","source":"_posts/java/volatile.md","raw":"---\ntitle: 【Java 并发】volatile 关键字基本理解与使用\ndate: 2020-11-24 16:15:22\ncategories: Java\ntags:\n  - 并发\n---\n\n## volatile 的三个特性\n\n- 保证可见性\n- **不保证原子性**\n- 禁止指令重排\n\n## 指令重排\n\n### 什么是指令重排\n\n处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n<!-- more -->\n\n可能发生重排的代码：（意思就是第二行代码可能会先执行，听起来是不是有点匪夷所思）\n\n```java\na = 1;\nb = 2;\n```\n\n一定不会重排的代码（因为第 2 行依赖第 1 行的结果）：\n\n```java\na = 2;\nb += a;\n```\n\n### 举栗子\n\n观察下面这段代码的运行结果，假设没有重排，那么运行结果只有可能是以下 3 种：\n\n- x = 1, y = 1（先执行了 `a = 1` , `b = 1` 再执行 `x = b` 和 `y = a`）\n- x = 0, y = 1（先执行了 `a = 1` , `x = b` 再执行 `b = 1` 和 `y = a`）\n- x = 1, y = 0（先执行了 `b = 1` , `y = a` 再执行 `a = 1` 和 `x = b`）\n\n```java\npublic class Main {\n\n    private static int x;\n    private static int y;\n    private static int a;\n    private static int b;\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            x = y = a = b = 0;\n\n            Thread t1 = new Thread(() -> {\n                a = 1;\n                x = b;\n            });\n\n            Thread t2 = new Thread(() -> {\n                b = 1;\n                y = a;\n            });\n\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n\n            System.out.println(\"i = \" + i + \", x = \" + x + \", y = \" + y);\n            if (x == 0 && y == 0) {\n                break;\n            }\n        }\n    }\n}\n```\n\n大概在运行几万次后会出现指令重排的现象，先执行了 `x = b` , `y = a` 再执行 `a = 1` 和 `b = 1`。结果就是 x 和 y 都等于 0。\n\n**解决办法**：给四个变量加上 `volatile` 关键字，就不会出现预期之外的重排了。\n\n## 可见性\n\n首先看一段代码：\n\n```java\npublic class Main {\n    private static boolean flag = true;\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        flag = false;\n    }\n\n}\n```\n\n执行结果应该是符合我们预期的，由于主线程修改 `flag = false` ，所以终止了另一个线程中的死循环。\n\n但是如果在 `flag = false` 前，让主线程睡一会：\n\n```java\npublic class Main {\n    private static boolean flag = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        Thread.sleep(1000);\n        flag = false;\n    }\n\n}\n```\n\n结果发现程序无法停止（依然处于死循环），这就体现了可见性的问题。每一个线程都会从**主存**中拷贝一份 `flag` 的副本到自己的**工作内存**，主线程中修改 `flag` 相当于修改了副本的值，然后再把副本的值刷到主存中。但是这个时候另一个线程并不知道主存中发生了什么变动， `while (flag)` 使用的依然是之前旧的副本，所以就导致了死循环，程序无法退出。（第一个例子是因为主线程跑得太快，在另一个线程开始从主存拷贝 `flag` 之前就已经把 `flag = false` 刷到主存里了）\n\n加上 `volatile` 关键字后：\n\n```java\npublic class Main {\n    private volatile static boolean flag = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(() -> {\n            while (flag) {\n            }\n        }).start();\n        Thread.sleep(1000);\n        flag = false;\n    }\n\n}\n```\n\n程序成功退出。原因是主线程把 `flag` 刷到主存的同时会使其他线程的 `flag` 副本失效，下一次再判断 `while (flag)` 的时候就会重新从主存读取。\n","slug":"java/volatile","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdv000dxeoa93swdz4h","content":"<h2 id=\"volatile-的三个特性\"><a href=\"#volatile-的三个特性\" class=\"headerlink\" title=\"volatile 的三个特性\"></a>volatile 的三个特性</h2><ul>\n<li>保证可见性</li>\n<li><strong>不保证原子性</strong></li>\n<li>禁止指令重排</li>\n</ul>\n<h2 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h2><h3 id=\"什么是指令重排\"><a href=\"#什么是指令重排\" class=\"headerlink\" title=\"什么是指令重排\"></a>什么是指令重排</h3><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<span id=\"more\"></span>\n\n<p>可能发生重排的代码：（意思就是第二行代码可能会先执行，听起来是不是有点匪夷所思）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\">b = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>一定不会重排的代码（因为第 2 行依赖第 1 行的结果）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\">b += a;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"举栗子\"><a href=\"#举栗子\" class=\"headerlink\" title=\"举栗子\"></a>举栗子</h3><p>观察下面这段代码的运行结果，假设没有重排，那么运行结果只有可能是以下 3 种：</p>\n<ul>\n<li>x &#x3D; 1, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>b = 1</code> 再执行 <code>x = b</code> 和 <code>y = a</code>）</li>\n<li>x &#x3D; 0, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>x = b</code> 再执行 <code>b = 1</code> 和 <code>y = a</code>）</li>\n<li>x &#x3D; 1, y &#x3D; 0（先执行了 <code>b = 1</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>x = b</code>）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class=\"line\">            x = y = a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                a = <span class=\"number\">1</span>;</span><br><span class=\"line\">                x = b;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                b = <span class=\"number\">1</span>;</span><br><span class=\"line\">                y = a;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i = &quot;</span> + i + <span class=\"string\">&quot;, x = &quot;</span> + x + <span class=\"string\">&quot;, y = &quot;</span> + y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概在运行几万次后会出现指令重排的现象，先执行了 <code>x = b</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>b = 1</code>。结果就是 x 和 y 都等于 0。</p>\n<p><strong>解决办法</strong>：给四个变量加上 <code>volatile</code> 关键字，就不会出现预期之外的重排了。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>首先看一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果应该是符合我们预期的，由于主线程修改 <code>flag = false</code> ，所以终止了另一个线程中的死循环。</p>\n<p>但是如果在 <code>flag = false</code> 前，让主线程睡一会：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果发现程序无法停止（依然处于死循环），这就体现了可见性的问题。每一个线程都会从<strong>主存</strong>中拷贝一份 <code>flag</code> 的副本到自己的<strong>工作内存</strong>，主线程中修改 <code>flag</code> 相当于修改了副本的值，然后再把副本的值刷到主存中。但是这个时候另一个线程并不知道主存中发生了什么变动， <code>while (flag)</code> 使用的依然是之前旧的副本，所以就导致了死循环，程序无法退出。（第一个例子是因为主线程跑得太快，在另一个线程开始从主存拷贝 <code>flag</code> 之前就已经把 <code>flag = false</code> 刷到主存里了）</p>\n<p>加上 <code>volatile</code> 关键字后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序成功退出。原因是主线程把 <code>flag</code> 刷到主存的同时会使其他线程的 <code>flag</code> 副本失效，下一次再判断 <code>while (flag)</code> 的时候就会重新从主存读取。</p>\n","site":{"data":{}},"length":1960,"excerpt":"<h2 id=\"volatile-的三个特性\"><a href=\"#volatile-的三个特性\" class=\"headerlink\" title=\"volatile 的三个特性\"></a>volatile 的三个特性</h2><ul>\n<li>保证可见性</li>\n<li><strong>不保证原子性</strong></li>\n<li>禁止指令重排</li>\n</ul>\n<h2 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h2><h3 id=\"什么是指令重排\"><a href=\"#什么是指令重排\" class=\"headerlink\" title=\"什么是指令重排\"></a>什么是指令重排</h3><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>","more":"<p>可能发生重排的代码：（意思就是第二行代码可能会先执行，听起来是不是有点匪夷所思）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\">b = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>一定不会重排的代码（因为第 2 行依赖第 1 行的结果）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\">b += a;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"举栗子\"><a href=\"#举栗子\" class=\"headerlink\" title=\"举栗子\"></a>举栗子</h3><p>观察下面这段代码的运行结果，假设没有重排，那么运行结果只有可能是以下 3 种：</p>\n<ul>\n<li>x &#x3D; 1, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>b = 1</code> 再执行 <code>x = b</code> 和 <code>y = a</code>）</li>\n<li>x &#x3D; 0, y &#x3D; 1（先执行了 <code>a = 1</code> , <code>x = b</code> 再执行 <code>b = 1</code> 和 <code>y = a</code>）</li>\n<li>x &#x3D; 1, y &#x3D; 0（先执行了 <code>b = 1</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>x = b</code>）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class=\"line\">            x = y = a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                a = <span class=\"number\">1</span>;</span><br><span class=\"line\">                x = b;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                b = <span class=\"number\">1</span>;</span><br><span class=\"line\">                y = a;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i = &quot;</span> + i + <span class=\"string\">&quot;, x = &quot;</span> + x + <span class=\"string\">&quot;, y = &quot;</span> + y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概在运行几万次后会出现指令重排的现象，先执行了 <code>x = b</code> , <code>y = a</code> 再执行 <code>a = 1</code> 和 <code>b = 1</code>。结果就是 x 和 y 都等于 0。</p>\n<p><strong>解决办法</strong>：给四个变量加上 <code>volatile</code> 关键字，就不会出现预期之外的重排了。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>首先看一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果应该是符合我们预期的，由于主线程修改 <code>flag = false</code> ，所以终止了另一个线程中的死循环。</p>\n<p>但是如果在 <code>flag = false</code> 前，让主线程睡一会：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果发现程序无法停止（依然处于死循环），这就体现了可见性的问题。每一个线程都会从<strong>主存</strong>中拷贝一份 <code>flag</code> 的副本到自己的<strong>工作内存</strong>，主线程中修改 <code>flag</code> 相当于修改了副本的值，然后再把副本的值刷到主存中。但是这个时候另一个线程并不知道主存中发生了什么变动， <code>while (flag)</code> 使用的依然是之前旧的副本，所以就导致了死循环，程序无法退出。（第一个例子是因为主线程跑得太快，在另一个线程开始从主存拷贝 <code>flag</code> 之前就已经把 <code>flag = false</code> 刷到主存里了）</p>\n<p>加上 <code>volatile</code> 关键字后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序成功退出。原因是主线程把 <code>flag</code> 刷到主存的同时会使其他线程的 <code>flag</code> 副本失效，下一次再判断 <code>while (flag)</code> 的时候就会重新从主存读取。</p>"},{"title":"使用 Vagrant 搭建开发环境","date":"2021-10-12T08:02:32.000Z","_content":"\n其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建**一次性**使用的开发环境时真的非常非常方便\n\n<!-- more -->\n\n## 需要安装的工具\n\n- [VirtualBox](https://www.virtualbox.org/)\n- [Vagrant](https://www.vagrantup.com/)\n\n## 入门\n\n> 更具体的推荐看[官方文档](https://www.vagrantup.com/docs)\n\n常用命令：\n\n```bash\nvagrant init bento/ubuntu-18.04 # 创建配置文件并指定 box\nvagrant up                      # 开机\nvagrant reload                  # 重启（重新加载配置）\nvagrant halt                    # 关机\nvagrant destroy                 # 销毁虚拟机\nvagrant box list                # 显示已下载的 box\n\nvagrant suspend                 # 暂停\nvagrant resume                  # 恢复\n\n# 添加 box，具体看 vagrant box add -h\nvagrant box add [options] <name, url, or path>\nvagrant box remove <name> # 删除 box\n```\n\n### box\n\n按照传统方法，装一台虚拟机，必须去某个 Linux 发行版的官网上下载 ISO 文件，然后打开 VMware 或者 VirtualBox，使用 ISO 一步一步创建虚拟机。而 Vagrant 提供了更简单的形式，一条命令就能从 box 创建并启动虚拟机\n\n可以在官网[搜索](https://app.vagrantup.com/boxes/search)现成的 box\n\n### Vagrantfile\n\n相当于虚拟机的配置文件，可以配置网络、内存、CPU、同步文件夹、端口映射等，使用 `vagrant init` 在当前目录创建配置模板\n\n一个最简单的配置文件就是仅指定 box，其他默认：\n\n```rb Vagrantfile\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\nend\n```\n\n接着 `vagrant up` 读取配置文件并运行虚拟机，然后就可以去泡杯咖啡，其他什么也不用管，一切交给 vagrant（前提是网络环境好的情况下，懂得都懂，怎么保证访问外网的速度 🧱），当不再需要的时候运行 `vagrant destroy` 销毁即可。\n\n## 更复杂的配置\n\n以最近自己用的 golang + docker 环境为例，其实主要部分就是一个 shell 脚本，然后配置了私有网络，修改硬件为 1 CPU 2G 内存\n\nshell 脚本默认情况下只会在第一次 `vagrant up` 的时候执行\n\n```rb Vagrantfile\n# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n$script = <<-'SCRIPT'\necho \"Setting timezone to Asia/Shanghai...\"\nsudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\necho \"Asia/Shanghai\" | sudo tee /etc/timezone\ndate\n\necho \"Using Aliyun mirrors...\"\nsudo tee /etc/apt/sources.list <<-'EOF'\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\nEOF\nsudo apt-get update\n# Comment apt upgrade to make vagrant up faster\n# sudo apt-get -y upgrade\n\necho \"Installing Docker...\"\nsudo apt-get remove docker docker-engine docker.io\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\nsudo apt-get -y update\nsudo apt-get -y install docker-ce\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo systemctl enable docker\n# Make sure we can actually use docker as the vagrant user\nsudo usermod -aG docker vagrant\nsudo docker --version\n\necho \"Installing Golang...\"\nGO_VERSION=1.17.2\ncurl -sSL https://gomirrors.org/dl/go/go${GO_VERSION}.linux-amd64.tar.gz -o /tmp/go.tgz\nsudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go.tgz\ntee -a /home/vagrant/.profile <<-'EOF'\nexport GOROOT=/usr/local/go\nexport GOPATH=/home/vagrant/go\nexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin\nEOF\nsource /home/vagrant/.profile\ngo version\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct\nmkdir -p /home/vagrant/go/{bin,pkg,src}\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\n  config.vm.network \"private_network\", ip: \"192.168.33.11\"\n\n  config.vm.provider \"virtualbox\" do |vb|\n    vb.cpus = \"1\"\n    vb.memory = \"2048\"\n  end\n\n  config.vm.provision \"shell\", inline: $script, privileged: false\nend\n```\n","source":"_posts/tool/vagrant.md","raw":"---\ntitle: 使用 Vagrant 搭建开发环境\ndate: 2021-10-12 16:02:32\ncategories: 开发工具\ntags:\n  - Vagrant\n  - VirtualBox\n---\n\n其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建**一次性**使用的开发环境时真的非常非常方便\n\n<!-- more -->\n\n## 需要安装的工具\n\n- [VirtualBox](https://www.virtualbox.org/)\n- [Vagrant](https://www.vagrantup.com/)\n\n## 入门\n\n> 更具体的推荐看[官方文档](https://www.vagrantup.com/docs)\n\n常用命令：\n\n```bash\nvagrant init bento/ubuntu-18.04 # 创建配置文件并指定 box\nvagrant up                      # 开机\nvagrant reload                  # 重启（重新加载配置）\nvagrant halt                    # 关机\nvagrant destroy                 # 销毁虚拟机\nvagrant box list                # 显示已下载的 box\n\nvagrant suspend                 # 暂停\nvagrant resume                  # 恢复\n\n# 添加 box，具体看 vagrant box add -h\nvagrant box add [options] <name, url, or path>\nvagrant box remove <name> # 删除 box\n```\n\n### box\n\n按照传统方法，装一台虚拟机，必须去某个 Linux 发行版的官网上下载 ISO 文件，然后打开 VMware 或者 VirtualBox，使用 ISO 一步一步创建虚拟机。而 Vagrant 提供了更简单的形式，一条命令就能从 box 创建并启动虚拟机\n\n可以在官网[搜索](https://app.vagrantup.com/boxes/search)现成的 box\n\n### Vagrantfile\n\n相当于虚拟机的配置文件，可以配置网络、内存、CPU、同步文件夹、端口映射等，使用 `vagrant init` 在当前目录创建配置模板\n\n一个最简单的配置文件就是仅指定 box，其他默认：\n\n```rb Vagrantfile\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\nend\n```\n\n接着 `vagrant up` 读取配置文件并运行虚拟机，然后就可以去泡杯咖啡，其他什么也不用管，一切交给 vagrant（前提是网络环境好的情况下，懂得都懂，怎么保证访问外网的速度 🧱），当不再需要的时候运行 `vagrant destroy` 销毁即可。\n\n## 更复杂的配置\n\n以最近自己用的 golang + docker 环境为例，其实主要部分就是一个 shell 脚本，然后配置了私有网络，修改硬件为 1 CPU 2G 内存\n\nshell 脚本默认情况下只会在第一次 `vagrant up` 的时候执行\n\n```rb Vagrantfile\n# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n$script = <<-'SCRIPT'\necho \"Setting timezone to Asia/Shanghai...\"\nsudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\necho \"Asia/Shanghai\" | sudo tee /etc/timezone\ndate\n\necho \"Using Aliyun mirrors...\"\nsudo tee /etc/apt/sources.list <<-'EOF'\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\nEOF\nsudo apt-get update\n# Comment apt upgrade to make vagrant up faster\n# sudo apt-get -y upgrade\n\necho \"Installing Docker...\"\nsudo apt-get remove docker docker-engine docker.io\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\nsudo apt-get -y update\nsudo apt-get -y install docker-ce\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo systemctl enable docker\n# Make sure we can actually use docker as the vagrant user\nsudo usermod -aG docker vagrant\nsudo docker --version\n\necho \"Installing Golang...\"\nGO_VERSION=1.17.2\ncurl -sSL https://gomirrors.org/dl/go/go${GO_VERSION}.linux-amd64.tar.gz -o /tmp/go.tgz\nsudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go.tgz\ntee -a /home/vagrant/.profile <<-'EOF'\nexport GOROOT=/usr/local/go\nexport GOPATH=/home/vagrant/go\nexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin\nEOF\nsource /home/vagrant/.profile\ngo version\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct\nmkdir -p /home/vagrant/go/{bin,pkg,src}\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"bento/ubuntu-18.04\"\n  config.vm.network \"private_network\", ip: \"192.168.33.11\"\n\n  config.vm.provider \"virtualbox\" do |vb|\n    vb.cpus = \"1\"\n    vb.memory = \"2048\"\n  end\n\n  config.vm.provision \"shell\", inline: $script, privileged: false\nend\n```\n","slug":"tool/vagrant","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmczdz000ixeoae4ls8h0d","content":"<p>其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建<strong>一次性</strong>使用的开发环境时真的非常非常方便</p>\n<span id=\"more\"></span>\n\n<h2 id=\"需要安装的工具\"><a href=\"#需要安装的工具\" class=\"headerlink\" title=\"需要安装的工具\"></a>需要安装的工具</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydHVhbGJveC5vcmcv\">VirtualBox<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS8=\">Vagrant<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><blockquote>\n<p>更具体的推荐看<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS9kb2Nz\">官方文档<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<p>常用命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant init bento/ubuntu-18.04 <span class=\"comment\"># 创建配置文件并指定 box</span></span><br><span class=\"line\">vagrant up                      <span class=\"comment\"># 开机</span></span><br><span class=\"line\">vagrant reload                  <span class=\"comment\"># 重启（重新加载配置）</span></span><br><span class=\"line\">vagrant halt                    <span class=\"comment\"># 关机</span></span><br><span class=\"line\">vagrant destroy                 <span class=\"comment\"># 销毁虚拟机</span></span><br><span class=\"line\">vagrant box list                <span class=\"comment\"># 显示已下载的 box</span></span><br><span class=\"line\"></span><br><span class=\"line\">vagrant <span class=\"built_in\">suspend</span>                 <span class=\"comment\"># 暂停</span></span><br><span class=\"line\">vagrant resume                  <span class=\"comment\"># 恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 box，具体看 vagrant box add -h</span></span><br><span class=\"line\">vagrant box add [options] &lt;name, url, or path&gt;</span><br><span class=\"line\">vagrant box remove &lt;name&gt; <span class=\"comment\"># 删除 box</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"box\"><a href=\"#box\" class=\"headerlink\" title=\"box\"></a>box</h3><p>按照传统方法，装一台虚拟机，必须去某个 Linux 发行版的官网上下载 ISO 文件，然后打开 VMware 或者 VirtualBox，使用 ISO 一步一步创建虚拟机。而 Vagrant 提供了更简单的形式，一条命令就能从 box 创建并启动虚拟机</p>\n<p>可以在官网<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcHAudmFncmFudHVwLmNvbS9ib3hlcy9zZWFyY2g=\">搜索<i class=\"fa fa-external-link-alt\"></i></span>现成的 box</p>\n<h3 id=\"Vagrantfile\"><a href=\"#Vagrantfile\" class=\"headerlink\" title=\"Vagrantfile\"></a>Vagrantfile</h3><p>相当于虚拟机的配置文件，可以配置网络、内存、CPU、同步文件夹、端口映射等，使用 <code>vagrant init</code> 在当前目录创建配置模板</p>\n<p>一个最简单的配置文件就是仅指定 box，其他默认：</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>接着 <code>vagrant up</code> 读取配置文件并运行虚拟机，然后就可以去泡杯咖啡，其他什么也不用管，一切交给 vagrant（前提是网络环境好的情况下，懂得都懂，怎么保证访问外网的速度 🧱），当不再需要的时候运行 <code>vagrant destroy</code> 销毁即可。</p>\n<h2 id=\"更复杂的配置\"><a href=\"#更复杂的配置\" class=\"headerlink\" title=\"更复杂的配置\"></a>更复杂的配置</h2><p>以最近自己用的 golang + docker 环境为例，其实主要部分就是一个 shell 脚本，然后配置了私有网络，修改硬件为 1 CPU 2G 内存</p>\n<p>shell 脚本默认情况下只会在第一次 <code>vagrant up</code> 的时候执行</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- mode: ruby -*-</span></span><br><span class=\"line\"><span class=\"comment\"># vi: set ft=ruby :</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$script</span> = <span class=\"string\">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Setting timezone to Asia/Shanghai...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Asia/Shanghai&quot; | sudo tee /etc/timezone</span></span><br><span class=\"line\"><span class=\"string\">date</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Using Aliyun mirrors...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get update</span></span><br><span class=\"line\"><span class=\"string\"># Comment apt upgrade to make vagrant up faster</span></span><br><span class=\"line\"><span class=\"string\"># sudo apt-get -y upgrade</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Installing Docker...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get remove docker docker-engine docker.io</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class=\"line\"><span class=\"string\">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class=\"line\"><span class=\"string\">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install docker-ce</span></span><br><span class=\"line\"><span class=\"string\">sudo mkdir -p /etc/docker</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl daemon-reload</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl restart docker</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl enable docker</span></span><br><span class=\"line\"><span class=\"string\"># Make sure we can actually use docker as the vagrant user</span></span><br><span class=\"line\"><span class=\"string\">sudo usermod -aG docker vagrant</span></span><br><span class=\"line\"><span class=\"string\">sudo docker --version</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Installing Golang...&quot;</span></span><br><span class=\"line\"><span class=\"string\">GO_VERSION=1.17.2</span></span><br><span class=\"line\"><span class=\"string\">curl -sSL https://gomirrors.org/dl/go/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz -o /tmp/go.tgz</span></span><br><span class=\"line\"><span class=\"string\">sudo rm -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf /tmp/go.tgz</span></span><br><span class=\"line\"><span class=\"string\">tee -a /home/vagrant/.profile &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">export GOROOT=/usr/local/go</span></span><br><span class=\"line\"><span class=\"string\">export GOPATH=/home/vagrant/go</span></span><br><span class=\"line\"><span class=\"string\">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">source /home/vagrant/.profile</span></span><br><span class=\"line\"><span class=\"string\">go version</span></span><br><span class=\"line\"><span class=\"string\">go env -w GO111MODULE=on</span></span><br><span class=\"line\"><span class=\"string\">go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct</span></span><br><span class=\"line\"><span class=\"string\">mkdir -p /home/vagrant/go/&#123;bin,pkg,src&#125;</span></span><br><span class=\"line\"><span class=\"string\">SCRIPT</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\">  config.vm.network <span class=\"string\">&quot;private_network&quot;</span>, <span class=\"symbol\">ip:</span> <span class=\"string\">&quot;192.168.33.11&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provider <span class=\"string\">&quot;virtualbox&quot;</span> <span class=\"keyword\">do</span> |<span class=\"params\">vb</span>|</span><br><span class=\"line\">    vb.cpus = <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">    vb.memory = <span class=\"string\">&quot;2048&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision <span class=\"string\">&quot;shell&quot;</span>, <span class=\"symbol\">inline:</span> <span class=\"variable\">$script</span>, <span class=\"symbol\">privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":3789,"excerpt":"<p>其实在学校的时候就开始轻度使用 Vagrant，但也仅仅作为一个虚拟机创建或者开关机的工具。来了公司实习后发现 Vagrant 在搭建<strong>一次性</strong>使用的开发环境时真的非常非常方便</p>","more":"<h2 id=\"需要安装的工具\"><a href=\"#需要安装的工具\" class=\"headerlink\" title=\"需要安装的工具\"></a>需要安装的工具</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlydHVhbGJveC5vcmcv\">VirtualBox<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS8=\">Vagrant<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><blockquote>\n<p>更具体的推荐看<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmFncmFudHVwLmNvbS9kb2Nz\">官方文档<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<p>常用命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vagrant init bento/ubuntu-18.04 <span class=\"comment\"># 创建配置文件并指定 box</span></span><br><span class=\"line\">vagrant up                      <span class=\"comment\"># 开机</span></span><br><span class=\"line\">vagrant reload                  <span class=\"comment\"># 重启（重新加载配置）</span></span><br><span class=\"line\">vagrant halt                    <span class=\"comment\"># 关机</span></span><br><span class=\"line\">vagrant destroy                 <span class=\"comment\"># 销毁虚拟机</span></span><br><span class=\"line\">vagrant box list                <span class=\"comment\"># 显示已下载的 box</span></span><br><span class=\"line\"></span><br><span class=\"line\">vagrant <span class=\"built_in\">suspend</span>                 <span class=\"comment\"># 暂停</span></span><br><span class=\"line\">vagrant resume                  <span class=\"comment\"># 恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加 box，具体看 vagrant box add -h</span></span><br><span class=\"line\">vagrant box add [options] &lt;name, url, or path&gt;</span><br><span class=\"line\">vagrant box remove &lt;name&gt; <span class=\"comment\"># 删除 box</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"box\"><a href=\"#box\" class=\"headerlink\" title=\"box\"></a>box</h3><p>按照传统方法，装一台虚拟机，必须去某个 Linux 发行版的官网上下载 ISO 文件，然后打开 VMware 或者 VirtualBox，使用 ISO 一步一步创建虚拟机。而 Vagrant 提供了更简单的形式，一条命令就能从 box 创建并启动虚拟机</p>\n<p>可以在官网<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcHAudmFncmFudHVwLmNvbS9ib3hlcy9zZWFyY2g=\">搜索<i class=\"fa fa-external-link-alt\"></i></span>现成的 box</p>\n<h3 id=\"Vagrantfile\"><a href=\"#Vagrantfile\" class=\"headerlink\" title=\"Vagrantfile\"></a>Vagrantfile</h3><p>相当于虚拟机的配置文件，可以配置网络、内存、CPU、同步文件夹、端口映射等，使用 <code>vagrant init</code> 在当前目录创建配置模板</p>\n<p>一个最简单的配置文件就是仅指定 box，其他默认：</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>接着 <code>vagrant up</code> 读取配置文件并运行虚拟机，然后就可以去泡杯咖啡，其他什么也不用管，一切交给 vagrant（前提是网络环境好的情况下，懂得都懂，怎么保证访问外网的速度 🧱），当不再需要的时候运行 <code>vagrant destroy</code> 销毁即可。</p>\n<h2 id=\"更复杂的配置\"><a href=\"#更复杂的配置\" class=\"headerlink\" title=\"更复杂的配置\"></a>更复杂的配置</h2><p>以最近自己用的 golang + docker 环境为例，其实主要部分就是一个 shell 脚本，然后配置了私有网络，修改硬件为 1 CPU 2G 内存</p>\n<p>shell 脚本默认情况下只会在第一次 <code>vagrant up</code> 的时候执行</p>\n<figure class=\"highlight rb\"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- mode: ruby -*-</span></span><br><span class=\"line\"><span class=\"comment\"># vi: set ft=ruby :</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$script</span> = <span class=\"string\">&lt;&lt;-&#x27;SCRIPT&#x27;</span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Setting timezone to Asia/Shanghai...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Asia/Shanghai&quot; | sudo tee /etc/timezone</span></span><br><span class=\"line\"><span class=\"string\">date</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Using Aliyun mirrors...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/apt/sources.list &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get update</span></span><br><span class=\"line\"><span class=\"string\"># Comment apt upgrade to make vagrant up faster</span></span><br><span class=\"line\"><span class=\"string\"># sudo apt-get -y upgrade</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Installing Docker...&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get remove docker docker-engine docker.io</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span></span><br><span class=\"line\"><span class=\"string\">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class=\"line\"><span class=\"string\">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y update</span></span><br><span class=\"line\"><span class=\"string\">sudo apt-get -y install docker-ce</span></span><br><span class=\"line\"><span class=\"string\">sudo mkdir -p /etc/docker</span></span><br><span class=\"line\"><span class=\"string\">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl daemon-reload</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl restart docker</span></span><br><span class=\"line\"><span class=\"string\">sudo systemctl enable docker</span></span><br><span class=\"line\"><span class=\"string\"># Make sure we can actually use docker as the vagrant user</span></span><br><span class=\"line\"><span class=\"string\">sudo usermod -aG docker vagrant</span></span><br><span class=\"line\"><span class=\"string\">sudo docker --version</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo &quot;Installing Golang...&quot;</span></span><br><span class=\"line\"><span class=\"string\">GO_VERSION=1.17.2</span></span><br><span class=\"line\"><span class=\"string\">curl -sSL https://gomirrors.org/dl/go/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz -o /tmp/go.tgz</span></span><br><span class=\"line\"><span class=\"string\">sudo rm -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf /tmp/go.tgz</span></span><br><span class=\"line\"><span class=\"string\">tee -a /home/vagrant/.profile &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\"><span class=\"string\">export GOROOT=/usr/local/go</span></span><br><span class=\"line\"><span class=\"string\">export GOPATH=/home/vagrant/go</span></span><br><span class=\"line\"><span class=\"string\">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">source /home/vagrant/.profile</span></span><br><span class=\"line\"><span class=\"string\">go version</span></span><br><span class=\"line\"><span class=\"string\">go env -w GO111MODULE=on</span></span><br><span class=\"line\"><span class=\"string\">go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct</span></span><br><span class=\"line\"><span class=\"string\">mkdir -p /home/vagrant/go/&#123;bin,pkg,src&#125;</span></span><br><span class=\"line\"><span class=\"string\">SCRIPT</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(<span class=\"string\">&quot;2&quot;</span>) <span class=\"keyword\">do</span> |<span class=\"params\">config</span>|</span><br><span class=\"line\">  config.vm.box = <span class=\"string\">&quot;bento/ubuntu-18.04&quot;</span></span><br><span class=\"line\">  config.vm.network <span class=\"string\">&quot;private_network&quot;</span>, <span class=\"symbol\">ip:</span> <span class=\"string\">&quot;192.168.33.11&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provider <span class=\"string\">&quot;virtualbox&quot;</span> <span class=\"keyword\">do</span> |<span class=\"params\">vb</span>|</span><br><span class=\"line\">    vb.cpus = <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">    vb.memory = <span class=\"string\">&quot;2048&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision <span class=\"string\">&quot;shell&quot;</span>, <span class=\"symbol\">inline:</span> <span class=\"variable\">$script</span>, <span class=\"symbol\">privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>"},{"title":"1 核 1G 的 VPS 能玩出什么花样","date":"2022-03-27T06:25:47.000Z","_content":"\n最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 `nohup`, `systemd` 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 `ssh` 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...\n\n<!-- more -->\n\n## 免备案\n\n没有什么歪门邪道，如果嫌备案麻烦，就老老实实多花一点钱买个香港的机子（或者新加坡，日本，洛杉矶 ...），跑一些个人小项目足矣。它们不仅免备案，**而且**在使用大部分包管理工具的时候都可以直接用默认的源，👍 速度超赞\n\n## CapRover\n\n[CapRover](https://caprover.com/) 是 Heroku 的 self-hosted 替代方案，它完全开源，每月 5$ 的 1C1G 机子就可以运行\n\n### 对比\n\n其实 [Dokku](https://dokku.com/) 也挺不错，只是我更喜欢在 Web 界面上操作，`Dockerfile` 也能满足大部分应用的需求。最重要的是 CapRover 有一个叫 **One Click Apps** 的功能，能一键部署 Gitea, Gitlab, Drone, Wordpress, Ghost 等常见应用，😅 有点像宝塔，有一说一还挺香\n\n|              CapRover               |      Dokku      |     Heroku      |\n| :---------------------------------: | :-------------: | :-------------: |\n|                便宜                 |      便宜       |       贵        |\n| 只支持 Dockerfile 或 docker-compose | 各种 buildpacks | 各种 buildpacks |\n|             有 Web 界面             |   ShellScript   |   有 Web 界面   |\n|          基于 Docker Swarm          |   基于 Docker   |        -        |\n\n### 安装\n\n照着官网的 [Getting Started](https://caprover.com/docs/get-started.html) 慢慢做就行，注意得提前安装好 Docker：\n\n```bash\ncurl -fsSL https://get.docker.com | sh\n```\n\n## Apps\n\n我现在部署的一些 App：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271825038.png)\n\n### go-import-redirector\n\nGolang 导包的重定向器，在[开源](https://github.com/rsc/go-import-redirector)的基础上做了点改造\n\n能把 `go get` 从自定义域名重定向到 GitHub：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271833111.png)\n\n或者浏览器直接打开，跳转到 GoDoc：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271830848.png)\n\n### tinyurl\n\n自己写的短链接工具，没啥高级功能，**能跑就行**\n\n[t.chensl.me/lc1016](https://t.chensl.me/lc1016)\n\n### Portainer\n\nDocker 的 Web 界面，结合着 CapRover 用来管理容器\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271855823.png)\n\n### Syncthing\n\n一个去中心化的文件同步工具，经常需要用它和室友互传一些文件（😈 不可告人的文件）\n\n### FileBrowser\n\n结合 Syncthing 使用，在没有安装 Syncthing 的电脑上也能在线管理文件\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271901985.png)\n","source":"_posts/vps/selfhosted.md","raw":"---\ntitle: 1 核 1G 的 VPS 能玩出什么花样\ndate: 2022-03-27 14:25:47\ncategories: VPS\ntags:\n  - Vultr\n  - PaaS\n  - Heroku\n  - Dokku\n  - self-hosted\n  - CapRover\n---\n\n最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 `nohup`, `systemd` 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 `ssh` 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...\n\n<!-- more -->\n\n## 免备案\n\n没有什么歪门邪道，如果嫌备案麻烦，就老老实实多花一点钱买个香港的机子（或者新加坡，日本，洛杉矶 ...），跑一些个人小项目足矣。它们不仅免备案，**而且**在使用大部分包管理工具的时候都可以直接用默认的源，👍 速度超赞\n\n## CapRover\n\n[CapRover](https://caprover.com/) 是 Heroku 的 self-hosted 替代方案，它完全开源，每月 5$ 的 1C1G 机子就可以运行\n\n### 对比\n\n其实 [Dokku](https://dokku.com/) 也挺不错，只是我更喜欢在 Web 界面上操作，`Dockerfile` 也能满足大部分应用的需求。最重要的是 CapRover 有一个叫 **One Click Apps** 的功能，能一键部署 Gitea, Gitlab, Drone, Wordpress, Ghost 等常见应用，😅 有点像宝塔，有一说一还挺香\n\n|              CapRover               |      Dokku      |     Heroku      |\n| :---------------------------------: | :-------------: | :-------------: |\n|                便宜                 |      便宜       |       贵        |\n| 只支持 Dockerfile 或 docker-compose | 各种 buildpacks | 各种 buildpacks |\n|             有 Web 界面             |   ShellScript   |   有 Web 界面   |\n|          基于 Docker Swarm          |   基于 Docker   |        -        |\n\n### 安装\n\n照着官网的 [Getting Started](https://caprover.com/docs/get-started.html) 慢慢做就行，注意得提前安装好 Docker：\n\n```bash\ncurl -fsSL https://get.docker.com | sh\n```\n\n## Apps\n\n我现在部署的一些 App：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271825038.png)\n\n### go-import-redirector\n\nGolang 导包的重定向器，在[开源](https://github.com/rsc/go-import-redirector)的基础上做了点改造\n\n能把 `go get` 从自定义域名重定向到 GitHub：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271833111.png)\n\n或者浏览器直接打开，跳转到 GoDoc：\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271830848.png)\n\n### tinyurl\n\n自己写的短链接工具，没啥高级功能，**能跑就行**\n\n[t.chensl.me/lc1016](https://t.chensl.me/lc1016)\n\n### Portainer\n\nDocker 的 Web 界面，结合着 CapRover 用来管理容器\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271855823.png)\n\n### Syncthing\n\n一个去中心化的文件同步工具，经常需要用它和室友互传一些文件（😈 不可告人的文件）\n\n### FileBrowser\n\n结合 Syncthing 使用，在没有安装 Syncthing 的电脑上也能在线管理文件\n\n![](https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271901985.png)\n","slug":"vps/selfhosted","published":1,"updated":"2022-04-02T08:34:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1hmcze3000mxeoae2y6gy2x","content":"<p>最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 <code>nohup</code>, <code>systemd</code> 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 <code>ssh</code> 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...</p>\n<span id=\"more\"></span>\n\n<h2 id=\"免备案\"><a href=\"#免备案\" class=\"headerlink\" title=\"免备案\"></a>免备案</h2><p>没有什么歪门邪道，如果嫌备案麻烦，就老老实实多花一点钱买个香港的机子（或者新加坡，日本，洛杉矶 ...），跑一些个人小项目足矣。它们不仅免备案，<strong>而且</strong>在使用大部分包管理工具的时候都可以直接用默认的源，👍 速度超赞</p>\n<h2 id=\"CapRover\"><a href=\"#CapRover\" class=\"headerlink\" title=\"CapRover\"></a>CapRover</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jYXByb3Zlci5jb20v\">CapRover<i class=\"fa fa-external-link-alt\"></i></span> 是 Heroku 的 self-hosted 替代方案，它完全开源，每月 5$ 的 1C1G 机子就可以运行</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>其实 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2trdS5jb20v\">Dokku<i class=\"fa fa-external-link-alt\"></i></span> 也挺不错，只是我更喜欢在 Web 界面上操作，<code>Dockerfile</code> 也能满足大部分应用的需求。最重要的是 CapRover 有一个叫 <strong>One Click Apps</strong> 的功能，能一键部署 Gitea, Gitlab, Drone, Wordpress, Ghost 等常见应用，😅 有点像宝塔，有一说一还挺香</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">CapRover</th>\n<th align=\"center\">Dokku</th>\n<th align=\"center\">Heroku</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">便宜</td>\n<td align=\"center\">便宜</td>\n<td align=\"center\">贵</td>\n</tr>\n<tr>\n<td align=\"center\">只支持 Dockerfile 或 docker-compose</td>\n<td align=\"center\">各种 buildpacks</td>\n<td align=\"center\">各种 buildpacks</td>\n</tr>\n<tr>\n<td align=\"center\">有 Web 界面</td>\n<td align=\"center\">ShellScript</td>\n<td align=\"center\">有 Web 界面</td>\n</tr>\n<tr>\n<td align=\"center\">基于 Docker Swarm</td>\n<td align=\"center\">基于 Docker</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>照着官网的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jYXByb3Zlci5jb20vZG9jcy9nZXQtc3RhcnRlZC5odG1s\">Getting Started<i class=\"fa fa-external-link-alt\"></i></span> 慢慢做就行，注意得提前安装好 Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Apps\"><a href=\"#Apps\" class=\"headerlink\" title=\"Apps\"></a>Apps</h2><p>我现在部署的一些 App：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271825038.png\" loading=\"lazy\"></p>\n<h3 id=\"go-import-redirector\"><a href=\"#go-import-redirector\" class=\"headerlink\" title=\"go-import-redirector\"></a>go-import-redirector</h3><p>Golang 导包的重定向器，在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JzYy9nby1pbXBvcnQtcmVkaXJlY3Rvcg==\">开源<i class=\"fa fa-external-link-alt\"></i></span>的基础上做了点改造</p>\n<p>能把 <code>go get</code> 从自定义域名重定向到 GitHub：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271833111.png\" loading=\"lazy\"></p>\n<p>或者浏览器直接打开，跳转到 GoDoc：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271830848.png\" loading=\"lazy\"></p>\n<h3 id=\"tinyurl\"><a href=\"#tinyurl\" class=\"headerlink\" title=\"tinyurl\"></a>tinyurl</h3><p>自己写的短链接工具，没啥高级功能，<strong>能跑就行</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90LmNoZW5zbC5tZS9sYzEwMTY=\">t.chensl.me&#x2F;lc1016<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"Portainer\"><a href=\"#Portainer\" class=\"headerlink\" title=\"Portainer\"></a>Portainer</h3><p>Docker 的 Web 界面，结合着 CapRover 用来管理容器</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271855823.png\" loading=\"lazy\"></p>\n<h3 id=\"Syncthing\"><a href=\"#Syncthing\" class=\"headerlink\" title=\"Syncthing\"></a>Syncthing</h3><p>一个去中心化的文件同步工具，经常需要用它和室友互传一些文件（😈 不可告人的文件）</p>\n<h3 id=\"FileBrowser\"><a href=\"#FileBrowser\" class=\"headerlink\" title=\"FileBrowser\"></a>FileBrowser</h3><p>结合 Syncthing 使用，在没有安装 Syncthing 的电脑上也能在线管理文件</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271901985.png\" loading=\"lazy\"></p>\n","site":{"data":{}},"length":1024,"excerpt":"<p>最开始第一台阿里云服务器，在上面跑服务都是纯手工编译打包，上传到服务器，然后再用 <code>nohup</code>, <code>systemd</code> 之类的工具挂在后台。后来学了 Docker，再后来用一些 Docker 的图形界面（portainer）省去了 <code>ssh</code> 进服务器敲命令的过程。但是配置域名，依然需要折腾 nginx 或者 Caddy，如果是境内服务器还需要走麻烦的备案流程。所以，最近尝试了几个 PaaS 方案，它们通常能自动化编译、部署、配置域名反向代理、SSL 证书自动续期 ...</p>","more":"<h2 id=\"免备案\"><a href=\"#免备案\" class=\"headerlink\" title=\"免备案\"></a>免备案</h2><p>没有什么歪门邪道，如果嫌备案麻烦，就老老实实多花一点钱买个香港的机子（或者新加坡，日本，洛杉矶 ...），跑一些个人小项目足矣。它们不仅免备案，<strong>而且</strong>在使用大部分包管理工具的时候都可以直接用默认的源，👍 速度超赞</p>\n<h2 id=\"CapRover\"><a href=\"#CapRover\" class=\"headerlink\" title=\"CapRover\"></a>CapRover</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jYXByb3Zlci5jb20v\">CapRover<i class=\"fa fa-external-link-alt\"></i></span> 是 Heroku 的 self-hosted 替代方案，它完全开源，每月 5$ 的 1C1G 机子就可以运行</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>其实 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2trdS5jb20v\">Dokku<i class=\"fa fa-external-link-alt\"></i></span> 也挺不错，只是我更喜欢在 Web 界面上操作，<code>Dockerfile</code> 也能满足大部分应用的需求。最重要的是 CapRover 有一个叫 <strong>One Click Apps</strong> 的功能，能一键部署 Gitea, Gitlab, Drone, Wordpress, Ghost 等常见应用，😅 有点像宝塔，有一说一还挺香</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">CapRover</th>\n<th align=\"center\">Dokku</th>\n<th align=\"center\">Heroku</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">便宜</td>\n<td align=\"center\">便宜</td>\n<td align=\"center\">贵</td>\n</tr>\n<tr>\n<td align=\"center\">只支持 Dockerfile 或 docker-compose</td>\n<td align=\"center\">各种 buildpacks</td>\n<td align=\"center\">各种 buildpacks</td>\n</tr>\n<tr>\n<td align=\"center\">有 Web 界面</td>\n<td align=\"center\">ShellScript</td>\n<td align=\"center\">有 Web 界面</td>\n</tr>\n<tr>\n<td align=\"center\">基于 Docker Swarm</td>\n<td align=\"center\">基于 Docker</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>照着官网的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jYXByb3Zlci5jb20vZG9jcy9nZXQtc3RhcnRlZC5odG1s\">Getting Started<i class=\"fa fa-external-link-alt\"></i></span> 慢慢做就行，注意得提前安装好 Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Apps\"><a href=\"#Apps\" class=\"headerlink\" title=\"Apps\"></a>Apps</h2><p>我现在部署的一些 App：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271825038.png\" loading=\"lazy\"></p>\n<h3 id=\"go-import-redirector\"><a href=\"#go-import-redirector\" class=\"headerlink\" title=\"go-import-redirector\"></a>go-import-redirector</h3><p>Golang 导包的重定向器，在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JzYy9nby1pbXBvcnQtcmVkaXJlY3Rvcg==\">开源<i class=\"fa fa-external-link-alt\"></i></span>的基础上做了点改造</p>\n<p>能把 <code>go get</code> 从自定义域名重定向到 GitHub：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271833111.png\" loading=\"lazy\"></p>\n<p>或者浏览器直接打开，跳转到 GoDoc：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271830848.png\" loading=\"lazy\"></p>\n<h3 id=\"tinyurl\"><a href=\"#tinyurl\" class=\"headerlink\" title=\"tinyurl\"></a>tinyurl</h3><p>自己写的短链接工具，没啥高级功能，<strong>能跑就行</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90LmNoZW5zbC5tZS9sYzEwMTY=\">t.chensl.me&#x2F;lc1016<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"Portainer\"><a href=\"#Portainer\" class=\"headerlink\" title=\"Portainer\"></a>Portainer</h3><p>Docker 的 Web 界面，结合着 CapRover 用来管理容器</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271855823.png\" loading=\"lazy\"></p>\n<h3 id=\"Syncthing\"><a href=\"#Syncthing\" class=\"headerlink\" title=\"Syncthing\"></a>Syncthing</h3><p>一个去中心化的文件同步工具，经常需要用它和室友互传一些文件（😈 不可告人的文件）</p>\n<h3 id=\"FileBrowser\"><a href=\"#FileBrowser\" class=\"headerlink\" title=\"FileBrowser\"></a>FileBrowser</h3><p>结合 Syncthing 使用，在没有安装 Syncthing 的电脑上也能在线管理文件</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/MaoLongLong/images/202203271901985.png\" loading=\"lazy\"></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1hmczdc0001xeoa0czehi1r","category_id":"cl1hmczdl0004xeoa3bp983q8","_id":"cl1hmczdw000exeoaa4td7va7"},{"post_id":"cl1hmczdg0003xeoa9vcz2koq","category_id":"cl1hmczdt000axeoa9xdjb32p","_id":"cl1hmcze2000kxeoa382jbz8t"},{"post_id":"cl1hmczdq0007xeoad2nvftzg","category_id":"cl1hmczdt000axeoa9xdjb32p","_id":"cl1hmcze4000oxeoaeb8adzzz"},{"post_id":"cl1hmczdr0008xeoae3ca07bd","category_id":"cl1hmczdt000axeoa9xdjb32p","_id":"cl1hmcze5000rxeoa47tmdmgs"},{"post_id":"cl1hmczds0009xeoa5mqw6lyo","category_id":"cl1hmcze4000nxeoa47h8b0uv","_id":"cl1hmcze6000wxeoaf44e5y1z"},{"post_id":"cl1hmczdu000cxeoafq5f8b4m","category_id":"cl1hmcze5000sxeoaay8gbuzv","_id":"cl1hmcze80013xeoa35h8gxte"},{"post_id":"cl1hmczdv000dxeoa93swdz4h","category_id":"cl1hmcze5000sxeoaay8gbuzv","_id":"cl1hmcze90015xeoa5yxw8z9z"},{"post_id":"cl1hmczdz000ixeoae4ls8h0d","category_id":"cl1hmcze90016xeoa1ivk4bbb","_id":"cl1hmczeb001cxeoacf2p01os"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","category_id":"cl1hmczea0019xeoa491w9yei","_id":"cl1hmczeb001gxeoac7g23je5"}],"PostTag":[{"post_id":"cl1hmczdc0001xeoa0czehi1r","tag_id":"cl1hmczdp0005xeoa94csbit1","_id":"cl1hmcze5000qxeoaboghdc60"},{"post_id":"cl1hmczdc0001xeoa0czehi1r","tag_id":"cl1hmczdt000bxeoa3eg50hrc","_id":"cl1hmcze6000txeoa0ixm9hrh"},{"post_id":"cl1hmczdc0001xeoa0czehi1r","tag_id":"cl1hmczdw000gxeoa9rv8aony","_id":"cl1hmcze6000vxeoa455m9s4p"},{"post_id":"cl1hmczdc0001xeoa0czehi1r","tag_id":"cl1hmcze2000lxeoags15197r","_id":"cl1hmcze6000xxeoa7nl9gdmw"},{"post_id":"cl1hmczdg0003xeoa9vcz2koq","tag_id":"cl1hmcze5000pxeoa2agce7xo","_id":"cl1hmcze70010xeoaeuj276xi"},{"post_id":"cl1hmczdq0007xeoad2nvftzg","tag_id":"cl1hmcze6000uxeoah2fj6dz3","_id":"cl1hmcze80011xeoahjrwcfto"},{"post_id":"cl1hmczdr0008xeoae3ca07bd","tag_id":"cl1hmcze7000zxeoad7f09bzi","_id":"cl1hmczeb001bxeoa061j7pm7"},{"post_id":"cl1hmczdr0008xeoae3ca07bd","tag_id":"cl1hmcze80014xeoabznm44y6","_id":"cl1hmczeb001dxeoae4z72edy"},{"post_id":"cl1hmczdr0008xeoae3ca07bd","tag_id":"cl1hmcze90017xeoafxcscej2","_id":"cl1hmczeb001fxeoabktf974e"},{"post_id":"cl1hmczds0009xeoa5mqw6lyo","tag_id":"cl1hmczea001axeoaa35ncg0c","_id":"cl1hmczec001hxeoa2h4d4vas"},{"post_id":"cl1hmczdu000cxeoafq5f8b4m","tag_id":"cl1hmcze7000zxeoad7f09bzi","_id":"cl1hmczec001jxeoabse2d4fk"},{"post_id":"cl1hmczdv000dxeoa93swdz4h","tag_id":"cl1hmcze7000zxeoad7f09bzi","_id":"cl1hmczed001lxeoa937v11qn"},{"post_id":"cl1hmczdz000ixeoae4ls8h0d","tag_id":"cl1hmczec001kxeoa1gt8a0mc","_id":"cl1hmczee001oxeoa8tjscodo"},{"post_id":"cl1hmczdz000ixeoae4ls8h0d","tag_id":"cl1hmczed001mxeoa7xr81g2f","_id":"cl1hmczee001pxeoa2ppg1113"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczed001nxeoa1skch0b0","_id":"cl1hmczeg001vxeoa6n6e33da"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczee001qxeoa3az9cxnp","_id":"cl1hmczeg001wxeoa14nlbjwb"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczee001rxeoa8xasccm6","_id":"cl1hmczeg001xxeoahy1ph535"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczef001sxeoa1nd9hdk5","_id":"cl1hmczeg001yxeoabd0f6jtx"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczef001txeoadiujcbu6","_id":"cl1hmczeg001zxeoa9wlz8hxa"},{"post_id":"cl1hmcze3000mxeoae2y6gy2x","tag_id":"cl1hmczef001uxeoa0h198biw","_id":"cl1hmczeg0020xeoa6yrx1w5m"}],"Tag":[{"name":"Linux","_id":"cl1hmczdp0005xeoa94csbit1"},{"name":"Docker","_id":"cl1hmczdt000bxeoa3eg50hrc"},{"name":"OverlayFS","_id":"cl1hmczdw000gxeoa9rv8aony"},{"name":"chroot","_id":"cl1hmcze2000lxeoags15197r"},{"name":"pool","_id":"cl1hmcze5000pxeoa2agce7xo"},{"name":"微服务","_id":"cl1hmcze6000uxeoah2fj6dz3"},{"name":"并发","_id":"cl1hmcze7000zxeoad7f09bzi"},{"name":"CAS","_id":"cl1hmcze80014xeoabznm44y6"},{"name":"unsafe","_id":"cl1hmcze90017xeoafxcscej2"},{"name":"LeetCode","_id":"cl1hmczea001axeoaa35ncg0c"},{"name":"Vagrant","_id":"cl1hmczec001kxeoa1gt8a0mc"},{"name":"VirtualBox","_id":"cl1hmczed001mxeoa7xr81g2f"},{"name":"Vultr","_id":"cl1hmczed001nxeoa1skch0b0"},{"name":"PaaS","_id":"cl1hmczee001qxeoa3az9cxnp"},{"name":"Heroku","_id":"cl1hmczee001rxeoa8xasccm6"},{"name":"Dokku","_id":"cl1hmczef001sxeoa1nd9hdk5"},{"name":"self-hosted","_id":"cl1hmczef001txeoadiujcbu6"},{"name":"CapRover","_id":"cl1hmczef001uxeoa0h198biw"}]}}